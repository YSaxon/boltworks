{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Boltworks \u00b6 A collection of various extensions for Slack's bolt library to help you more easily make better slackbots. CLI - Argparse decorator \u00b6 This allows you to use Python's argparse library to process complex command line flags and options in Slack Commands. All Slack parameters will be passed through to your method; you can use the 'args' catchall, and/or individual arguments like 'respond' or 'context' etc All other parameters will be parsed from the command string when the command is run. The explicit way \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 from boltworks import argparse_command import argparse parser = argparse.ArgumentParser() parser.add_argument('main_input', help='the main input you want to give') group = parser.add_mutually_exclusive_group() group.add_argument('--verbose', action='store_true', help='increase output verbosity') group.add_argument('--quiet', action='store_true', help='decrease output verbosity') parser.add_argument('--algorithm', choices=['knn', 'svm', 'rf'], help='choose the machine learning algorithm used') parser.add_argument('--numbers', nargs='+', type=int, help='list of numbers') parser.add_argument('-f', '--flag', action='store_true', help='toggle the flag') @app.command(re.compile(\"/dothething\")) @argparse_command(parser) def do_the_thing(args: Args, main_input: str, verbose: bool, quiet: bool, algorithm: Optional[str], numbers: Optional[List[int]], flag: bool): if numbers and not quiet: args.respond(f\"your numbers sum to {sum(numbers)}\") #etcetera ``` #### The automagic way If you set automagic on, then providing an ArgParser is optional. Any type-hinted arguments not handled by an ArgParser you pass will be automagically added to an argparser with the appropriate names and types set. However there are some advanced features that aren't possible this way (such as mutually exclusive groups) and the help docs won't be as helpful. from boltworks import argparse_command @app.command(re.compile(\"/performthemagic\")) @argparse_command(automagic=True) def perform_the_magic(args: Args, main_input: str, quiet:Optional[bool]=False, numbers: Optional[list[int]]=[]): if numbers and not quiet: args.respond(f\"your numbers sum to {sum(numbers)}\") 1 2 3 4 ## GUI - ActionCallbacks This class allows you to easily serialize a method as a callback for a Slack UI element such as a button. These callbacks can themselves post UI elements with more callbacks for more complicated logic, and you can always use the `partial` class to inject some arguments into the callback method at the time you are creating the callback, as in the below example. DISK_CACHE_DIR=\"~/.diskcache\" from boltworks import ActionCallbacks,DiskCacheKVSTore from diskcache import Cache #pip install diskcache disk_cache=DiskCacheKVSTore(Cache(directory=DISK_CACHE_DIR)) callbacks=ActionCallbacks(app,disk_cache.using_serializer(dill)) def get_elapsed_time(args:Args, start:datetime): now = datetime.now() diff = now - start days, seconds = diff.days, diff.seconds hours, minutes, seconds = seconds // 3600, (seconds % 3600) // 60, seconds % 60 1 2 3 formatted_diff = f\"{days} day{'s' if days > 1 else ''}, \" formatted_diff += f\"{hours:02d}:{minutes:02d}:{seconds:02d}\" args.respond(f\"time elapsed: {formatted_diff}\") def start_timer(args:Args): now=datetime.now() get_elapsed_button=callbacks.get_button_register_callback(\"get elapsed time\",partial(get_elapsed_time,start=now)) timer_started_message=\"Timer started at \"+now.strftime(\"%A, %B %d, %Y %I:%M:%S %p\") block=slack_sdk.models.blocks.SectionBlock(text=timer_started_message,accessory=get_elapsed_button) args.say(blocks=[block]) start_timer_button=callbacks.get_button_register_callback(\"start a timer\",start_timer) timer_start_block=slack_sdk.models.blocks.SectionBlock(text=\"click here to start a timer\",accessory=start_timer_button) app.client.chat_postMessage(blocks=[timer_start_block],channel=CHANNEL_ID) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 ## GUI - ThreadCallbacks Similiar to ActionCallbacks, this class allows you to register a message's `ts` (timestamp used by slack as a message id), so that your callback will be called any time a message is posted to that Thread. ## GUI - NodeTreeUI This is the beefiest module of the repo. It allows you to display complex nested information neatly, in a user-clickable, expanding and contracting view. The TreeNodeUI class handles all the logic of formatting these trees and responding to clicks. You just need to put your information into the tree datastructure, using the flexible TreeNode and TreeNodeContainer classes. Fundamentally a TreeNode has two things: * A format it itself displays when it is visible, either a string, or for more complex formatting, a Slack Block or list thereof * Children Nodes, organized into containers, that it can optionally hide or reveal. The visibility of these Children Nodes is controlled by UI elements. Fundamentally there are two types of Child Containers. * regular ChildContainers, which have a single list of Node Children; These are formatted as buttons and can be clicked to expand/show their children, or clicked again to contract/hide their children. * MenuChildContainers which contain within them multiple labeled lists of Node Children. These can be StaticMenus, OverflowMenus, or RadioButtons, and in each case, selecting an option reveals only its Children. All the other fields you will see within TreeNodes and NodeContainers are concerned with the exact details of how those containers are formatted. You can always directly instantiate a TreeNode or NodeContainer, but there are also static helper methods defined on some classes to help more easily construct frequently used variants of those classes. Among these are methods to convert a jsonlike recursively nested dict/list object into a nested TreeNode. (TODO: insert examples of TreeNode usage here)","title":"home"},{"location":"#boltworks","text":"A collection of various extensions for Slack's bolt library to help you more easily make better slackbots.","title":"Boltworks"},{"location":"#cli---argparse-decorator","text":"This allows you to use Python's argparse library to process complex command line flags and options in Slack Commands. All Slack parameters will be passed through to your method; you can use the 'args' catchall, and/or individual arguments like 'respond' or 'context' etc All other parameters will be parsed from the command string when the command is run.","title":"CLI - Argparse decorator"},{"location":"#the-explicit-way","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 from boltworks import argparse_command import argparse parser = argparse.ArgumentParser() parser.add_argument('main_input', help='the main input you want to give') group = parser.add_mutually_exclusive_group() group.add_argument('--verbose', action='store_true', help='increase output verbosity') group.add_argument('--quiet', action='store_true', help='decrease output verbosity') parser.add_argument('--algorithm', choices=['knn', 'svm', 'rf'], help='choose the machine learning algorithm used') parser.add_argument('--numbers', nargs='+', type=int, help='list of numbers') parser.add_argument('-f', '--flag', action='store_true', help='toggle the flag') @app.command(re.compile(\"/dothething\")) @argparse_command(parser) def do_the_thing(args: Args, main_input: str, verbose: bool, quiet: bool, algorithm: Optional[str], numbers: Optional[List[int]], flag: bool): if numbers and not quiet: args.respond(f\"your numbers sum to {sum(numbers)}\") #etcetera ``` #### The automagic way If you set automagic on, then providing an ArgParser is optional. Any type-hinted arguments not handled by an ArgParser you pass will be automagically added to an argparser with the appropriate names and types set. However there are some advanced features that aren't possible this way (such as mutually exclusive groups) and the help docs won't be as helpful. from boltworks import argparse_command @app.command(re.compile(\"/performthemagic\")) @argparse_command(automagic=True) def perform_the_magic(args: Args, main_input: str, quiet:Optional[bool]=False, numbers: Optional[list[int]]=[]): if numbers and not quiet: args.respond(f\"your numbers sum to {sum(numbers)}\") 1 2 3 4 ## GUI - ActionCallbacks This class allows you to easily serialize a method as a callback for a Slack UI element such as a button. These callbacks can themselves post UI elements with more callbacks for more complicated logic, and you can always use the `partial` class to inject some arguments into the callback method at the time you are creating the callback, as in the below example. DISK_CACHE_DIR=\"~/.diskcache\" from boltworks import ActionCallbacks,DiskCacheKVSTore from diskcache import Cache #pip install diskcache disk_cache=DiskCacheKVSTore(Cache(directory=DISK_CACHE_DIR)) callbacks=ActionCallbacks(app,disk_cache.using_serializer(dill)) def get_elapsed_time(args:Args, start:datetime): now = datetime.now() diff = now - start days, seconds = diff.days, diff.seconds hours, minutes, seconds = seconds // 3600, (seconds % 3600) // 60, seconds % 60 1 2 3 formatted_diff = f\"{days} day{'s' if days > 1 else ''}, \" formatted_diff += f\"{hours:02d}:{minutes:02d}:{seconds:02d}\" args.respond(f\"time elapsed: {formatted_diff}\") def start_timer(args:Args): now=datetime.now() get_elapsed_button=callbacks.get_button_register_callback(\"get elapsed time\",partial(get_elapsed_time,start=now)) timer_started_message=\"Timer started at \"+now.strftime(\"%A, %B %d, %Y %I:%M:%S %p\") block=slack_sdk.models.blocks.SectionBlock(text=timer_started_message,accessory=get_elapsed_button) args.say(blocks=[block]) start_timer_button=callbacks.get_button_register_callback(\"start a timer\",start_timer) timer_start_block=slack_sdk.models.blocks.SectionBlock(text=\"click here to start a timer\",accessory=start_timer_button) app.client.chat_postMessage(blocks=[timer_start_block],channel=CHANNEL_ID) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 ## GUI - ThreadCallbacks Similiar to ActionCallbacks, this class allows you to register a message's `ts` (timestamp used by slack as a message id), so that your callback will be called any time a message is posted to that Thread. ## GUI - NodeTreeUI This is the beefiest module of the repo. It allows you to display complex nested information neatly, in a user-clickable, expanding and contracting view. The TreeNodeUI class handles all the logic of formatting these trees and responding to clicks. You just need to put your information into the tree datastructure, using the flexible TreeNode and TreeNodeContainer classes. Fundamentally a TreeNode has two things: * A format it itself displays when it is visible, either a string, or for more complex formatting, a Slack Block or list thereof * Children Nodes, organized into containers, that it can optionally hide or reveal. The visibility of these Children Nodes is controlled by UI elements. Fundamentally there are two types of Child Containers. * regular ChildContainers, which have a single list of Node Children; These are formatted as buttons and can be clicked to expand/show their children, or clicked again to contract/hide their children. * MenuChildContainers which contain within them multiple labeled lists of Node Children. These can be StaticMenus, OverflowMenus, or RadioButtons, and in each case, selecting an option reveals only its Children. All the other fields you will see within TreeNodes and NodeContainers are concerned with the exact details of how those containers are formatted. You can always directly instantiate a TreeNode or NodeContainer, but there are also static helper methods defined on some classes to help more easily construct frequently used variants of those classes. Among these are methods to convert a jsonlike recursively nested dict/list object into a nested TreeNode. (TODO: insert examples of TreeNode usage here)","title":"The explicit way"},{"location":"api/","text":"Top-level package for Slack Bolt UI Extensions. boltworks \u00b6 Main module. cli special \u00b6 argparse_decorator \u00b6 argparse_command ( argparser = None , echo_back = True , do_ack = True , automagic = False ) \u00b6 This is the primary method for this feature. It is a decorator that you put onto your Slack Command Method to parse the arguments in the command and pass them to your function. You can either construct an argparse.ArgumentParser yourself to do the work (better) Or set automagic=True to have a simple ArgumentParser constructed for you based on your method signature (faster) Any parameter names in your method signature which Slack would usually inject (eg 'args' or 'say' or 'logger' etc) will be passed through. 1 2 3 4 5 6 7 8 9 10 argparser = argparse.ArgumentParser() argparser.add_argument(\"--a\", nargs=\"*\", type=float) argparser.add_argument(\"-b\", type=int) argparser.add_argument(\"c\") argparser.add_argument(\"d\", nargs=\"?\", default=\"default\") @app.command(\"/dothething\") @argparse_command(parser) def your_method_name(args:Args, say, a, b, c, d): ... can be called as /dothething cc dd --a 1 2 3 -b 5 In automagic mode, to have a parameter be called as --foo, make it KeywordOnly by placing it after a single asterisk. Otherwise the argument name is silent 1 2 3 4 @app.command(\"/dotheotherthing\") @argparse_command(automagic=True) def your_method_name(args:Args, say, a:str, b:list[int], *, c:int, d:int): ... can be called as /dotheotherthing test 1 2 3 --d 6 --c 5 (You are allowed to use Automagic together with an ArgumentParser as well to fill in an extra arg not handled by the parser) In both cases, the argparser library will always insert a --help parameter, though it will be better documented if you build your own ArgumentParser. It's recommended when you configure the Command in Slack to configure the usage string as [--help] to let people know they can do that. Parameters: Name Type Description Default argparser Optional[ArgumentParser] An optional argparse.ArgumentParser object with which to parse the arguments None echo_back bool description . Defaults to True. Calls 'say' to echo back the command executed to the user before executing it. True do_ack bool description . Defaults to True. Calls Slack's ack() method for you upon succesful parsing, so you don't have to do it yourself. True automagic bool description . Defaults to False. Enables automagic parsing of arguments based on your method signature. Only supported on Python>=3.9 False Exceptions: Type Description ValueError various ValueErrors can be raised, generally at the time of creation of the argparse_handler Source code in boltworks/cli/argparse_decorator.py def argparse_command ( argparser : Optional [ ArgumentParser ] = None , echo_back = True , do_ack = True , automagic = False ): \"\"\" This is the primary method for this feature. It is a decorator that you put onto your Slack Command Method to parse the arguments in the command and pass them to your function. You can either construct an argparse.ArgumentParser yourself to do the work (better) Or set automagic=True to have a simple ArgumentParser constructed for you based on your method signature (faster) Any parameter names in your method signature which Slack would usually inject (eg 'args' or 'say' or 'logger' etc) will be passed through. ``` argparser = argparse.ArgumentParser() argparser.add_argument(\"--a\", nargs=\"*\", type=float) argparser.add_argument(\"-b\", type=int) argparser.add_argument(\"c\") argparser.add_argument(\"d\", nargs=\"?\", default=\"default\") @app.command(\"/dothething\") @argparse_command(parser) def your_method_name(args:Args, say, a, b, c, d): ... ``` can be called as `/dothething cc dd --a 1 2 3 -b 5` In automagic mode, to have a parameter be called as --foo, make it KeywordOnly by placing it after a single asterisk. Otherwise the argument name is silent ``` @app.command(\"/dotheotherthing\") @argparse_command(automagic=True) def your_method_name(args:Args, say, a:str, b:list[int], *, c:int, d:int): ... ``` can be called as `/dotheotherthing test 1 2 3 --d 6 --c 5` (You are allowed to use Automagic together with an ArgumentParser as well to fill in an extra arg not handled by the parser) In both cases, the argparser library will always insert a `--help` parameter, though it will be better documented if you build your own ArgumentParser. It's recommended when you configure the Command in Slack to configure the usage string as `[--help]` to let people know they can do that. Args: argparser (Optional[ArgumentParser]): An optional argparse.ArgumentParser object with which to parse the arguments echo_back (bool, optional): _description_. Defaults to True. Calls 'say' to echo back the command executed to the user before executing it. do_ack (bool, optional): _description_. Defaults to True. Calls Slack's ack() method for you upon succesful parsing, so you don't have to do it yourself. automagic (bool, optional): _description_. Defaults to False. Enables automagic parsing of arguments based on your method signature. Only supported on Python>=3.9 Raises: ValueError: various ValueErrors can be raised, generally at the time of creation of the argparse_handler * If there are conflicts between slack-reserved argnames and your argparser names * If you don't have automagic set to True and don't pass an ArgumentParser, or the ArgumentParser doesn't handle all your method's params * If you use automagic, but don't sufficiently type-hint your parameters, or the types are too complicated etc. \"\"\" if not argparser : if not automagic : raise ValueError ( \"If you don't pass in an argparser, you must set automagic to True\" ) argparser = ArgumentParser () if automagic and sys . version_info < ( 3 , 9 ): raise ValueError ( \"automagic mode is not supported on Python versions < 3.9\" ) argparser_dests = [ a . dest for a in argparser . _actions if a . dest != \"help\" ] argname_conflicts = [ dest for dest in argparser_dests if dest in RESERVED_SLACK_ARGS ] if argname_conflicts : raise ValueError ( f \"One or more dest param names in your argparser conflict with built in param names used by slack bolt: { ', ' . join ( argname_conflicts ) } \\n Try setting the `dest` argument for those argparser actions to something else\" ) # if \"args\" in argparser_dests: # raise ValueError(f\"The 'args' param name is reserved for Slack, so you can't use it for an argparser argument name.\\nTry setting `the` dest parameter for that action to something else\") def _mid_func ( decorated_function ): midfunc_argparser = argparser deco_sig = inspect . signature ( decorated_function ) deco_argnames = [ a . name for a in deco_sig . parameters . values ()] deco_varargs = [ a . name for a in deco_sig . parameters . values () if a . kind == a . VAR_POSITIONAL ] if deco_varargs : raise ValueError ( f \"There is a varargs `* { deco_varargs [ 0 ] } ` in the method signature of the method you are decorating, which is unsupported. Please use a list instead\" ) deco_varkwargs = [ a . name for a in deco_sig . parameters . values () if a . kind == a . VAR_KEYWORD ] if not deco_varkwargs : #if there is no **kwargs to handle extra arguments... unhandled_arguments = [ dest for dest in argparser_dests if dest not in deco_argnames ] if unhandled_arguments : raise ValueError ( f \"The argparser object you provided generates one or more arguments ( { ',' . join ( unhandled_arguments ) } ) which are unhandled by the method you are decorating, nor does your method does not have a **kwargs to absorb them\" ) deco_extra_args_in_deco = [ a for a in deco_sig . parameters . values () if a . kind is not a . VAR_KEYWORD and a . name not in RESERVED_SLACK_ARGS and a . name not in argparser_dests ] deco_extra_args_in_deco_without_defaults = [ a for a in deco_extra_args_in_deco if a . default is a . empty ] if not automagic and deco_extra_args_in_deco_without_defaults : raise ValueError ( f \"The method you are decorating has one or more parameters without defaults defined that your argparser is not set to fill: { ',' . join ( deco_extra_args_in_deco ) } \" ) if automagic and deco_extra_args_in_deco : midfunc_argparser = automagically_add_args_to_argparser ( decorated_function , midfunc_argparser , deco_extra_args_in_deco ) def _inner_func_to_return_to_slack ( args : Args ): def fn ( message , file = None ): safe_post_in_blockquotes ( args . respond , message ) args . ack () innerfunc_argparser = copy . deepcopy ( midfunc_argparser ) #so we can have _print_message be unique to each call innerfunc_argparser . formatter_class = SlackArgParseFormatter innerfunc_argparser . _print_message = fn if args . command : command_base = args . command [ 'command' ] . replace ( \"*\" , \"\" ) if 'command' in args . command else '<cmd>' command_args = shlex . split ( args . command [ 'text' ] . replace ( \"*\" , \"\" )) if 'text' in args . command else [] elif args . message : split_message = shlex . split ( args . message [ 'text' ] . replace ( \"*\" , \"\" )) command_base = split_message [ 0 ] command_args = split_message [ 1 :] else : raise Exception ( \"This class is only to be used with @command or @message\" ) # unfortunately it's not possible to perfectly strip out the markup formatting so for now we are just stripping out asterisks # whenever they add 'blocks' to the command response, we can parse that to get the exact plaintext representation # see also https://stackoverflow.com/a/70627214/10773089 innerfunc_argparser . prog = command_base #maybe add more verbose explanation if you use `--var`` when it should have been `var`, or vice versa parsed_params = vars ( innerfunc_argparser . parse_args ( command_args )) if do_ack : args . ack () if echo_back : args . say ( text = f \"* { command_base } { ( shlex . join ( command_args )) } * \\t (run by <@ { args . context [ 'user_id' ] } >)\" ) available_slackvars_to_pass = { 'args' : args , ** vars ( args )} if deco_varkwargs : #if there's a varkwargs then just pass everything slackvars_to_pass = available_slackvars_to_pass else : slackvars_to_pass = { k : v for k , v in available_slackvars_to_pass . items () if k in deco_argnames } return decorated_function ( ** slackvars_to_pass , ** parsed_params ) return _inner_func_to_return_to_slack #on init, it will return a function that does all the above stuff when run return _mid_func gui special \u00b6 expandpointer \u00b6 ExpandPointer \u00b6 An ExpandPointer is a series of indexes into a Node Tree which recursively indicates which nodes to expand. This class is just a wrapper around Tuple. It exists as a seperate class mostly to avoid the somewhat more confusing tuple syntax for tuple literals. Source code in boltworks/gui/expandpointer.py class ExpandPointer : \"\"\" An ExpandPointer is a series of indexes into a Node Tree which recursively indicates which nodes to expand. This class is just a wrapper around Tuple. It exists as a seperate class mostly to avoid the somewhat more confusing tuple syntax for tuple literals. \"\"\" def __init__ ( self , values : Iterable [ int ]) -> None : self . _values : Tuple [ int , ... ] = tuple ( values ) @overload def __getitem__ ( self , index : int ) -> int : ... @overload def __getitem__ ( self , index : slice ) -> ExpandPointer : ... def __getitem__ ( self , index : Union [ int , slice ]) -> Union [ int , ExpandPointer ]: if isinstance ( index , int ): return self . _values [ index ] elif isinstance ( index , slice ): return ExpandPointer ( self . _values [ index ]) else : raise TypeError ( 'Index must be an int or slice' ) def __hash__ ( self ) -> int : return self . _values . __hash__ () def __len__ ( self ) -> int : return self . _values . __len__ () def __iter__ ( self ): return self . _values . __iter__ () def append ( self , val : int ) -> ExpandPointer : return ExpandPointer ( self . _values + ( val ,)) def extend ( self , obj : Iterable [ int ]) -> ExpandPointer : return ExpandPointer ( self . _values + tuple ( obj )) def __getstate__ ( self ): return self . _values def __setstate__ ( self , state ): self . _values = state treenodeui \u00b6 ButtonChildContainer ( ChildNodeContainer ) \u00b6 The most basic child node container, this represents a button Parameters: Name Type Description Default ChildNodeContainer _type_ description required Source code in boltworks/gui/treenodeui.py class ButtonChildContainer ( ChildNodeContainer ): \"\"\"The most basic child node container, this represents a button Args: ChildNodeContainer (_type_): _description_ \"\"\" def __init__ ( self , child_nodes : list [ TreeNode ], expand_button_format_string : str = NAMELESS_FMT_STR_EXPAND , collapse_button_format_string : str = NAMELESS_FMT_STR_COLLAPSE , static_button_text : Optional [ str ] = None , child_pageination : int = 10 ): self . child_nodes = child_nodes self . expand_button_format_string = expand_button_format_string if not static_button_text else static_button_text self . collapse_button_format_string = collapse_button_format_string if not static_button_text else static_button_text self . child_pageination = child_pageination def format_container ( self , rootkey : str , pointer_to_container : ExpandPointer , child_already_selected : int =- 1 ) -> InteractiveElement : if child_already_selected == - 1 : #if not already selected then it should be an expand button return TreeNodeUI . _button_to_replace_block ( rootkey = rootkey , expandpointer = pointer_to_container . append ( 0 ) #appending 0 to point to first node contained within this button , button_text = self . expand_button_format_string . format ( len ( self . child_nodes ))) else : return TreeNodeUI . _button_to_replace_block ( rootkey = rootkey , expandpointer = pointer_to_container [: - 1 ] #slicing off the last one to collapse this container and only show it's containing node , button_text = self . collapse_button_format_string . format ( len ( self . child_nodes )), style = \"danger\" ) @staticmethod def forJsonDetails ( jsonlike : list | dict , name : str = \"details\" , pageination = 15 , optimize_blocks = True ): children , numchildren = _jsonlike_to_treenode_and_truenum_children ( jsonlike , optimize_blocks = optimize_blocks , _level = 0 , pageination = pageination ) return ButtonChildContainer ( children , expand_button_format_string = name . format ( numchildren ) if name else NAMELESS_FMT_STR_EXPAND . format ( numchildren ), collapse_button_format_string = name . format ( numchildren ) if name else NAMELESS_FMT_STR_COLLAPSE . format ( numchildren ), child_pageination = pageination ) TreeNode \u00b6 The basic building block of this UI library, a Node has it's own Blocks, under formatblocks, and optionally, one or more child_containers containing one or more child nodes which can be expanded If there is only one childNodeContainer it will by default be placed on the side of the first formatblock If there is more than one, they will by default be placed on their own row, after the formatblocks This behavior can be overriden with the first_child_container_on_side param Source code in boltworks/gui/treenodeui.py class TreeNode : \"\"\"The basic building block of this UI library, a Node has it's own Blocks, under formatblocks, and optionally, one or more child_containers containing one or more child nodes which can be expanded If there is only one childNodeContainer it will by default be placed on the side of the first formatblock If there is more than one, they will by default be placed on their own row, after the formatblocks This behavior can be overriden with the `first_child_container_on_side` param \"\"\" def __init__ ( self , formatblocks : Union [ list [ Block ], Block , str ], children_containers : ChildNodeContainer | ChildNodeMenuContainer | list [ ChildNodeContainer | ChildNodeMenuContainer ] | None = None , first_child_container_on_side : Optional [ bool ] = None , auto_expand_children_if_only_one = False ): \"\"\"_summary_ Args: formatblocks (Union[list[Block],Block,str]): The formatting blocks for the node children_containers (ChildNodeContainer | ChildNodeMenuContainer | list[ChildNodeContainer | ChildNodeMenuContainer], optional): The whole point of the UI: these are interactive elements which if clicked/selected, will expand their child nodes underneath the node first_child_container_on_side (bool, optional): This overrides the default behavior, which is to put the first childNodeContainer on the side of the first formatting block IF it is the only childNodeContainer auto_expand_children_if_only_one (bool, optional): This option is deprecated and may be removed. It forces expand for any child that itself only has a single child node. Defaults to False. \"\"\" self . formatblocks = formatblocks self . children_containers = children_containers if isinstance ( children_containers , list ) else [ children_containers ] if children_containers else [] if first_child_container_on_side is not None : self . first_child_container_on_side = first_child_container_on_side # override else : self . first_child_container_on_side = len ( self . children_containers ) == 1 # default behavior for side placement self . auto_expand_children_if_only_one = auto_expand_children_if_only_one #delete? def __repr__ ( self ): toreturn = f \" { type ( self ) } \" if self . children_containers : toreturn += f \"( { len ( self . children_containers ) } children_containers, total grandchildren_nodes { sum ( len ( cc . child_nodes ) for cc in self . children_containers ) } ) \" toreturn += \": \" if isinstance ( self . formatblocks , str ): toreturn += self . formatblocks elif isinstance ( self . formatblocks , SectionBlock ): toreturn += self . formatblocks . text . text elif isinstance ( self . formatblocks , list ): toreturn += \" \\n \" . join ([ b . text . text if isinstance ( b , SectionBlock ) and b . text else b . to_dict () for b in self . formatblocks ]) return toreturn def text_formatting_as_str ( n ): #best try basis, not guaranteed to return correctly if isinstance ( n . formatblocks , str ): return n . formatblocks elif isinstance ( n . formatblocks , SectionBlock ): return n . formatblocks . text . text elif isinstance ( n . formatblocks , list ): return \" \\n \" . join ([ fb . text . text for fb in n . formatblocks if 'text' in fb . attributes ]) else : return \"\" #or raise exception?? @staticmethod def withSimpleSideButton ( formatblocks : Union [ list [ Block ], Block , str ], children : list [ TreeNode ] = [], expand_button_format_string : str = NAMELESS_FMT_STR_EXPAND , collapse_button_format_string : str = NAMELESS_FMT_STR_COLLAPSE , child_pageination : int = 10 ) -> TreeNode : \"\"\"A simple way to get a basic node with a side button expanding its children Args: formatblocks (Union[list[Block],Block,str]): the formatting blocks for the node itself children (list[TreeNode], optional): any children for the node expand_button_format_string (str, optional): a string for the side button if any, when it is not yet expanded, if {} is in the string, it will be replaced with the number of children collapse_button_format_string (str, optional): a string for the side button if any, when it is already expanded, if {} is in the string, it will be replaced with the number of children child_pageination (int, optional): _description_. Defaults to 10. Returns: TreeNode: the treenode requested \"\"\" return TreeNode ( formatblocks ,[ ButtonChildContainer ( children , expand_button_format_string , collapse_button_format_string , child_pageination = child_pageination )] if children else []) @staticmethod def fromJson ( formatblocks : Union [ str , Block , list [ Block ]], jsonlike : Union [ list , dict ], pageination = 15 , optimize_blocks = True ): return TreeNode ( formatblocks ,[ ButtonChildContainer . forJsonDetails ( jsonlike , \"details\" , pageination , optimize_blocks )]) __init__ ( self , formatblocks , children_containers = None , first_child_container_on_side = None , auto_expand_children_if_only_one = False ) special \u00b6 summary Parameters: Name Type Description Default formatblocks Union[list[Block],Block,str] The formatting blocks for the node required children_containers ChildNodeContainer | ChildNodeMenuContainer | list[ChildNodeContainer | ChildNodeMenuContainer] The whole point of the UI: these are interactive elements which if clicked/selected, will expand their child nodes underneath the node None first_child_container_on_side bool This overrides the default behavior, which is to put the first childNodeContainer on the side of the first formatting block IF it is the only childNodeContainer None auto_expand_children_if_only_one bool This option is deprecated and may be removed. It forces expand for any child that itself only has a single child node. Defaults to False. False Source code in boltworks/gui/treenodeui.py def __init__ ( self , formatblocks : Union [ list [ Block ], Block , str ], children_containers : ChildNodeContainer | ChildNodeMenuContainer | list [ ChildNodeContainer | ChildNodeMenuContainer ] | None = None , first_child_container_on_side : Optional [ bool ] = None , auto_expand_children_if_only_one = False ): \"\"\"_summary_ Args: formatblocks (Union[list[Block],Block,str]): The formatting blocks for the node children_containers (ChildNodeContainer | ChildNodeMenuContainer | list[ChildNodeContainer | ChildNodeMenuContainer], optional): The whole point of the UI: these are interactive elements which if clicked/selected, will expand their child nodes underneath the node first_child_container_on_side (bool, optional): This overrides the default behavior, which is to put the first childNodeContainer on the side of the first formatting block IF it is the only childNodeContainer auto_expand_children_if_only_one (bool, optional): This option is deprecated and may be removed. It forces expand for any child that itself only has a single child node. Defaults to False. \"\"\" self . formatblocks = formatblocks self . children_containers = children_containers if isinstance ( children_containers , list ) else [ children_containers ] if children_containers else [] if first_child_container_on_side is not None : self . first_child_container_on_side = first_child_container_on_side # override else : self . first_child_container_on_side = len ( self . children_containers ) == 1 # default behavior for side placement self . auto_expand_children_if_only_one = auto_expand_children_if_only_one #delete? withSimpleSideButton ( formatblocks , children = [], expand_button_format_string = 'expand {} ' , collapse_button_format_string = 'collapse {} ' , child_pageination = 10 ) staticmethod \u00b6 A simple way to get a basic node with a side button expanding its children Parameters: Name Type Description Default formatblocks Union[list[Block],Block,str] the formatting blocks for the node itself required children list[TreeNode] any children for the node [] expand_button_format_string str a string for the side button if any, when it is not yet expanded, if {} is in the string, it will be replaced with the number of children 'expand {}' collapse_button_format_string str a string for the side button if any, when it is already expanded, if {} is in the string, it will be replaced with the number of children 'collapse {}' child_pageination int description . Defaults to 10. 10 Returns: Type Description TreeNode the treenode requested Source code in boltworks/gui/treenodeui.py @staticmethod def withSimpleSideButton ( formatblocks : Union [ list [ Block ], Block , str ], children : list [ TreeNode ] = [], expand_button_format_string : str = NAMELESS_FMT_STR_EXPAND , collapse_button_format_string : str = NAMELESS_FMT_STR_COLLAPSE , child_pageination : int = 10 ) -> TreeNode : \"\"\"A simple way to get a basic node with a side button expanding its children Args: formatblocks (Union[list[Block],Block,str]): the formatting blocks for the node itself children (list[TreeNode], optional): any children for the node expand_button_format_string (str, optional): a string for the side button if any, when it is not yet expanded, if {} is in the string, it will be replaced with the number of children collapse_button_format_string (str, optional): a string for the side button if any, when it is already expanded, if {} is in the string, it will be replaced with the number of children child_pageination (int, optional): _description_. Defaults to 10. Returns: TreeNode: the treenode requested \"\"\" return TreeNode ( formatblocks ,[ ButtonChildContainer ( children , expand_button_format_string , collapse_button_format_string , child_pageination = child_pageination )] if children else []) TreeNodeUI \u00b6 Source code in boltworks/gui/treenodeui.py class TreeNodeUI : def __init__ ( self , app : App , kvstore : KVStore ) -> None : \"\"\"This is the managing class for the NodeUI, which handles posting nodes and then responding to InteractiveElements to expand/contract node children Args: app (App): A Slack Bolt App instance, for posting and registering actionhandlers kvstore (_type_): a KVStore instance, for storing and looking up Nodes \"\"\" app . action ( re . compile ( f \" { prefix_for_callback } .*\" ))( self . _do_callback_action ) self . expiring_root_dict = ExpiringDict ( max_age_seconds = 120 , max_len = 20 ) self . kvstore = kvstore #.namespaced(prefix_for_callback) self . _slack_chat_client = app . client def post_single_node ( self , post_callable_or_channel : str | Say | Respond , node : TreeNode , alt_text : str = None , expand_first : bool = False ): \"\"\"Posts a Single Node Args: post_callable_or_channel: either an instance of Respond or Say, or a channelid to post to node (TreeNode): the node to post alt_text (str, optional): for notifications that require a simple string expand_first (bool, optional): if set to True, the Node will post with its first child container expanded [to its first menu option] \"\"\" say = Say ( self . _slack_chat_client , post_callable_or_channel ) if isinstance ( post_callable_or_channel , str ) else post_callable_or_channel rootkey = self . _rootkey_from_treenode ( node ) return say ( text = alt_text or node . text_formatting_as_str (), blocks = self . _format_tree ( rootkey , expand_first = expand_first ), unfurl_links = False ) def post_treenodes ( self , post_callable_or_channel : str | Say | Respond , treenodes : list [ TreeNode ], post_all_together : bool , global_header : str = None , * , message_if_none : str = None , expand_first_if_seperate = False , ** other_global_tn_kwargs ): \"\"\"Posts multiple Nodes together Args: post_callable_or_channel (Union[PostMethod,str]): either an instance of Respond or Say, or a channelid to post to treenodes (list[TreeNode]): the nodes to post post_all_together (bool): if True, will collect the nodes under a parent node so they can all be collapsed together to save space global_header (str, optional): if posting together, this will be the text of the parent node, otherwise just a header posted before the nodes message_if_none (str, optional): optionally, provide a string to post if there are no nodes expand_first_if_seperate (bool, optional): like expand_first for post_single_node, only effective if posting the blocks seperately \"\"\" say = Say ( self . _slack_chat_client , post_callable_or_channel ) if isinstance ( post_callable_or_channel , str ) else post_callable_or_channel if not treenodes : if message_if_none : say ( message_if_none ) return if post_all_together : num_treenodes = f \" ( { len ( treenodes ) } ) \" if len ( treenodes ) > 1 else \"\" alt_text = f \" { global_header } : { num_treenodes } { treenodes [ 0 ] . text_formatting_as_str () } \" say ( text = alt_text , blocks = self . _format_tree ( self . _rootkey_from_treenode ( TreeNode . withSimpleSideButton ( formatblocks = global_header if global_header else [], children = treenodes , ** other_global_tn_kwargs )), expand_first = True ), unfurl_links = False ) else : if global_header : say ( text = global_header ) for node in treenodes : rootkey = self . _rootkey_from_treenode ( node ) alt_text = node . text_formatting_as_str () say ( text = alt_text , blocks = self . _format_tree ( rootkey , expand_first = expand_first_if_seperate ), unfurl_links = False ) def _rootkey_from_treenode ( self , node : TreeNode ): rootkey = str ( uuid1 ()) self . kvstore [ rootkey ] = node self . expiring_root_dict [ rootkey ] = node return rootkey def _get_root ( self , rootkey : str ) -> TreeNode : if rootkey in self . expiring_root_dict : return self . expiring_root_dict [ rootkey ] root = self . kvstore [ rootkey ] self . expiring_root_dict [ rootkey ] = root return root def _do_callback_action ( self , ack , action , respond ): # if logging.root.level<=logging.DEBUG: # self.profiler.start() ack () #find a way of threading that maybe? callback_data = action [ 'action_id' ][ len ( prefix_for_callback ):] rootkey , expandpointer = self . _deserialize_callback ( callback_data ) value = action [ 'selected_option' ][ 'value' ] if 'selected_option' in action and 'value' in action [ 'selected_option' ] else None if value : if int ( value ) == - 1 : #deselect expandpointer = expandpointer [: - 1 ] else : expandpointer = expandpointer . extend ([ int ( value ), 0 ]) blocks = self . _format_tree ( rootkey , expandpointer = expandpointer ) response = respond ( replace_original = True , blocks = blocks ) if isinstance ( response , WebhookResponse ): if response . status_code != 200 : respond ( f \"error in slack handling: { response . body } \" , replace_original = False ) print ( f \" { datetime . datetime . now () } : error in slack handling: { response . body } \" ) return response # if logging.root.level<=logging.DEBUG: # self.profiler.stop() # print(self.profiler.output_text(unicode=True, color=True)) @staticmethod def _button_to_replace_block ( button_text : str , rootkey : str , expandpointer : ExpandPointer , ** format_options ): serialized_data = TreeNodeUI . _serialize_callback ( rootkey , expandpointer ) button = ButtonElement ( text = button_text , action_id = f \" { serialized_data } \" , ** format_options ) return button @staticmethod def _serialize_callback ( rootkey : str , expandpointer : ExpandPointer ) -> str : serialized_pointer = ',' . join ([ str ( v ) for v in expandpointer ]) return f \" { prefix_for_callback }{ rootkey } ^ { serialized_pointer } \" @staticmethod def _deserialize_callback ( data : str ) -> Tuple [ str , ExpandPointer ]: rootkey , serialized_pointer = data . rsplit ( '^' , 1 ) pointerelems = serialized_pointer . split ( ',' ) expandpointer = ExpandPointer ([ int ( p ) for p in pointerelems ]) return rootkey , expandpointer def _format_tree ( self , rootkey : str , * , expandpointer : ExpandPointer = ExpandPointer ([ 0 ]), expand_first = False ): root = self . _get_root ( rootkey ) if expand_first and root . children_containers : if isinstance ( root . children_containers [ 0 ], ChildNodeContainer ): expandpointer = ExpandPointer ([ 0 , 0 , 0 ]) elif isinstance ( root . children_containers [ 0 ], ChildNodeMenuContainer ): expandpointer = ExpandPointer ([ 0 , 0 , 0 , 0 ]) diminish_pageination_by = 0 blocks_to_return = self . _format_tree_recursive ( parentnodes = [ root ], expandpointer = expandpointer , ancestral_pointer = ExpandPointer ([]), rootkey = rootkey , parents_pagination = 1 , diminish_pageination_by = 0 ) if len ( blocks_to_return ) > 50 : #this could probably be made more efficient, but for now, this should suffice while len ( blocks_to_return ) > 49 : diminish_pageination_by += 1 blocks_to_return = self . _format_tree_recursive ( parentnodes = [ root ], expandpointer = expandpointer , ancestral_pointer = ExpandPointer ([]), rootkey = rootkey , parents_pagination = 1 , diminish_pageination_by = diminish_pageination_by ) blocks_to_return . append ( ContextBlock ( elements = [ MarkdownTextObject ( text = \"(blocks were repaginated to avoid exceeding slack limits)\" )])) return blocks_to_return def _format_tree_recursive ( self , parentnodes : list [ TreeNode ], expandpointer : ExpandPointer , #:list[int], #could just make last one the start_at pointer and only go deeper if theres more ancestral_pointer : ExpandPointer , rootkey : str , parents_pagination : int = 10 , diminish_pageination_by = 0 #in case we exceed block limits, we can retry with some number here to recursively diminish the pageination ) -> list [ Block ]: parents_pagination = parents_pagination if not diminish_pageination_by else max ( 1 , parents_pagination - diminish_pageination_by ) child_insert , remaining_expandpointer = expandpointer [ 0 ], expandpointer [ 1 :] num_parents = len ( parentnodes ) start_at = self . _startat ( child_insert , parents_pagination ) end_at = self . _endat ( start_at , parents_pagination , num_parents ) blocks : list [ Block ] = [] before_blocks = [ blocks for number , node in enumerate ( parentnodes [ start_at : child_insert ], start_at ) for blocks in self . _formatblock ( node , ancestral_pointer . append ( number ), rootkey )] blocks . extend ( before_blocks ) blocks_for_pointed_node = self . _formatblock ( parentnodes [ child_insert ], ancestral_pointer . append ( child_insert ), rootkey , remaining_expandpointer ) blocks . extend ( blocks_for_pointed_node ) if remaining_expandpointer : #if there are more nodes to expand in the pointer list new_parent = parentnodes [ child_insert ] children_containers = new_parent . children_containers if remaining_expandpointer [ 0 ] > len ( new_parent . children_containers ): #transitional remaining_expandpointer = ExpandPointer ([ 0 , 0 ]) if len ( remaining_expandpointer ) == 1 : #transitional remaining_expandpointer = ExpandPointer ([ 0 ]) . extend ( remaining_expandpointer ) container_opened_index = remaining_expandpointer [ 0 ] selected_container = children_containers [ container_opened_index ] if isinstance ( selected_container , ChildNodeContainer ): selected_container_blocks = self . _format_tree_recursive ( parentnodes = selected_container . child_nodes if selected_container . child_nodes else [ TreeNode ( \"_(this pane is empty)_\" )], parents_pagination = selected_container . child_pageination , expandpointer = remaining_expandpointer [ 1 :], ancestral_pointer = ancestral_pointer . append ( child_insert ) . append ( remaining_expandpointer [ 0 ]), rootkey = rootkey , diminish_pageination_by = diminish_pageination_by ) else : assert isinstance ( selected_container , ChildNodeMenuContainer ) selected_container_blocks = self . _format_tree_recursive ( parentnodes = selected_container . child_nodes [ remaining_expandpointer [ 1 ]] if selected_container . child_nodes and selected_container . child_nodes [ remaining_expandpointer [ 1 ]] else [ TreeNode ( \"_(this pane is empty)_\" )], parents_pagination = selected_container . child_pageination , expandpointer = remaining_expandpointer [ 2 :], #since this contains multiple lists of nodes, we need two pointer indexes to find the next node to show ancestral_pointer = ancestral_pointer . append ( child_insert ) . append ( remaining_expandpointer [ 0 ]) . append ( remaining_expandpointer [ 1 ]), rootkey = rootkey , diminish_pageination_by = diminish_pageination_by ) blocks . extend ( selected_container_blocks ) after_blocks = [ blocks for number , node in enumerate ( parentnodes [ child_insert + 1 : end_at ], child_insert + 1 ) for blocks in self . _formatblock ( node , ancestral_pointer . append ( number ), rootkey )] blocks . extend ( after_blocks ) navig_blocks = self . _make_prev_next_buttons ( usePrev = start_at > 0 , useNext = end_at < num_parents , prev_callback = ( rootkey , ancestral_pointer . append ( start_at - parents_pagination if start_at - parents_pagination > 0 else 0 )), next_callback = ( rootkey , ancestral_pointer . append ( start_at + parents_pagination ))) #if startat+parents_per_page<num_parents else 0 if navig_blocks : blocks . append ( navig_blocks ) return blocks def _formatblock ( self , node : TreeNode , pointer_to_block : ExpandPointer , rootkey : str , remaining_expandpointer : ExpandPointer = None ): blocks : list [ Block ] = [] if isinstance ( node . formatblocks , list ): blocks . extend ( node . formatblocks ) elif isinstance ( node . formatblocks , Block ): blocks . append ( node . formatblocks ) elif isinstance ( node . formatblocks , str ) and node . formatblocks : blocks . append ( simple_slack_block ( node . formatblocks )) def format_nth_container ( n ): if not remaining_expandpointer or remaining_expandpointer [ 0 ] != n : return node . children_containers [ n ] . format_container ( rootkey , pointer_to_block . append ( n ), - 1 ) else : child_selected = remaining_expandpointer [ 1 ] if isinstance ( node . children_containers [ n ], ChildNodeMenuContainer ) and len ( remaining_expandpointer ) > 1 else 0 return node . children_containers [ n ] . format_container ( rootkey , pointer_to_block . append ( n ), child_selected ) if node . children_containers : if node . first_child_container_on_side and blocks and 'accessory' in blocks [ 0 ] . attributes : #and not blocks[0].accessory blocks [ 0 ] . accessory = format_nth_container ( 0 ) # type: ignore start_at = 1 else : start_at = 0 after_blocks_container_elements = ( format_nth_container ( n ) for n in range ( start_at , len ( node . children_containers ))) blocks . extend ( ActionsBlock ( elements = buttons_chunk ) for buttons_chunk in chunked ( after_blocks_container_elements , ActionsBlock . elements_max_length )) return blocks def _make_prev_next_buttons ( self , usePrev : bool , useNext : bool , prev_callback : Tuple [ str , ExpandPointer ], next_callback : Tuple [ str , ExpandPointer ]) -> Optional [ ActionsBlock ]: if ( not usePrev ) and ( not useNext ): return None buttons = [] if ( usePrev ): buttons . append ( self . _button_to_replace_block ( \":arrow_left:\" , * prev_callback )) if ( useNext ): buttons . append ( self . _button_to_replace_block ( \":arrow_right:\" , * next_callback )) navig_buttons = ActionsBlock ( elements = buttons ) return navig_buttons def _startat ( self , value , pageinate ): mod = value % pageinate return value - mod if value >= pageinate else 0 def _endat ( self , startat , pageinate , length ): return startat + pageinate if startat + pageinate < length else length __init__ ( self , app , kvstore ) special \u00b6 This is the managing class for the NodeUI, which handles posting nodes and then responding to InteractiveElements to expand/contract node children Parameters: Name Type Description Default app App A Slack Bolt App instance, for posting and registering actionhandlers required kvstore _type_ a KVStore instance, for storing and looking up Nodes required Source code in boltworks/gui/treenodeui.py def __init__ ( self , app : App , kvstore : KVStore ) -> None : \"\"\"This is the managing class for the NodeUI, which handles posting nodes and then responding to InteractiveElements to expand/contract node children Args: app (App): A Slack Bolt App instance, for posting and registering actionhandlers kvstore (_type_): a KVStore instance, for storing and looking up Nodes \"\"\" app . action ( re . compile ( f \" { prefix_for_callback } .*\" ))( self . _do_callback_action ) self . expiring_root_dict = ExpiringDict ( max_age_seconds = 120 , max_len = 20 ) self . kvstore = kvstore #.namespaced(prefix_for_callback) self . _slack_chat_client = app . client post_single_node ( self , post_callable_or_channel , node , alt_text = None , expand_first = False ) \u00b6 Posts a Single Node Parameters: Name Type Description Default post_callable_or_channel str | Say | Respond either an instance of Respond or Say, or a channelid to post to required node TreeNode the node to post required alt_text str for notifications that require a simple string None expand_first bool if set to True, the Node will post with its first child container expanded [to its first menu option] False Source code in boltworks/gui/treenodeui.py def post_single_node ( self , post_callable_or_channel : str | Say | Respond , node : TreeNode , alt_text : str = None , expand_first : bool = False ): \"\"\"Posts a Single Node Args: post_callable_or_channel: either an instance of Respond or Say, or a channelid to post to node (TreeNode): the node to post alt_text (str, optional): for notifications that require a simple string expand_first (bool, optional): if set to True, the Node will post with its first child container expanded [to its first menu option] \"\"\" say = Say ( self . _slack_chat_client , post_callable_or_channel ) if isinstance ( post_callable_or_channel , str ) else post_callable_or_channel rootkey = self . _rootkey_from_treenode ( node ) return say ( text = alt_text or node . text_formatting_as_str (), blocks = self . _format_tree ( rootkey , expand_first = expand_first ), unfurl_links = False ) post_treenodes ( self , post_callable_or_channel , treenodes , post_all_together , global_header = None , * , message_if_none = None , expand_first_if_seperate = False , ** other_global_tn_kwargs ) \u00b6 Posts multiple Nodes together Parameters: Name Type Description Default post_callable_or_channel Union[PostMethod,str] either an instance of Respond or Say, or a channelid to post to required treenodes list[TreeNode] the nodes to post required post_all_together bool if True, will collect the nodes under a parent node so they can all be collapsed together to save space required global_header str if posting together, this will be the text of the parent node, otherwise just a header posted before the nodes None message_if_none str optionally, provide a string to post if there are no nodes None expand_first_if_seperate bool like expand_first for post_single_node, only effective if posting the blocks seperately False Source code in boltworks/gui/treenodeui.py def post_treenodes ( self , post_callable_or_channel : str | Say | Respond , treenodes : list [ TreeNode ], post_all_together : bool , global_header : str = None , * , message_if_none : str = None , expand_first_if_seperate = False , ** other_global_tn_kwargs ): \"\"\"Posts multiple Nodes together Args: post_callable_or_channel (Union[PostMethod,str]): either an instance of Respond or Say, or a channelid to post to treenodes (list[TreeNode]): the nodes to post post_all_together (bool): if True, will collect the nodes under a parent node so they can all be collapsed together to save space global_header (str, optional): if posting together, this will be the text of the parent node, otherwise just a header posted before the nodes message_if_none (str, optional): optionally, provide a string to post if there are no nodes expand_first_if_seperate (bool, optional): like expand_first for post_single_node, only effective if posting the blocks seperately \"\"\" say = Say ( self . _slack_chat_client , post_callable_or_channel ) if isinstance ( post_callable_or_channel , str ) else post_callable_or_channel if not treenodes : if message_if_none : say ( message_if_none ) return if post_all_together : num_treenodes = f \" ( { len ( treenodes ) } ) \" if len ( treenodes ) > 1 else \"\" alt_text = f \" { global_header } : { num_treenodes } { treenodes [ 0 ] . text_formatting_as_str () } \" say ( text = alt_text , blocks = self . _format_tree ( self . _rootkey_from_treenode ( TreeNode . withSimpleSideButton ( formatblocks = global_header if global_header else [], children = treenodes , ** other_global_tn_kwargs )), expand_first = True ), unfurl_links = False ) else : if global_header : say ( text = global_header ) for node in treenodes : rootkey = self . _rootkey_from_treenode ( node ) alt_text = node . text_formatting_as_str () say ( text = alt_text , blocks = self . _format_tree ( rootkey , expand_first = expand_first_if_seperate ), unfurl_links = False ) slack_block_optimize_treenode ( children ) \u00b6 This method will try to reduce the number of formatting blocks used by a list of Treenode, to fit more blocks without pageinating or going over the slack limit of 50 Parameters: Name Type Description Default children list[TreeNode] the nodes to optimize required Returns: Type Description list[TreeNode] a fewer number of nodes, with some adjacent ones combined Source code in boltworks/gui/treenodeui.py def slack_block_optimize_treenode ( children : list [ TreeNode ]) -> list [ TreeNode ]: \"\"\"This method will try to reduce the number of formatting blocks used by a list of Treenode, to fit more blocks without pageinating or going over the slack limit of 50 Args: children (list[TreeNode]): the nodes to optimize Returns: list[TreeNode]: a fewer number of nodes, with some adjacent ones combined \"\"\" if not children : return [] out_children = [] combined_node_buffer = None #will always be either None or a TreeNode with a str as formattingblocks for n in children : if not _is_simple_text_block ( n ) or n . children_containers : #if the nodes have complicated blocks or children if combined_node_buffer : out_children . append ( combined_node_buffer ) #then just flush the buffer combined_node_buffer = None out_children . append ( n ) #and append this node else : #a simple terminal block that we can combine with other ones to optimize block count: if isinstance ( n . formatblocks , SectionBlock ): n . formatblocks = n . formatblocks . text . text if n . formatblocks . text else '' #convert it to using strings elif isinstance ( n . formatblocks , list ) and isinstance ( n . formatblocks [ 0 ], SectionBlock ): n . formatblocks = n . formatblocks [ 0 ] . text . text if n . formatblocks [ 0 ] . text else '' if not combined_node_buffer : #if no buffer, just start one combined_node_buffer = n else : #otherwise add the string to existing combined_tn, assuming it fits in char limits if len ( combined_node_buffer . formatblocks ) + len ( n . formatblocks ) + 2 < 3000 : #slack char limits for a single section block combined_node_buffer . formatblocks += \" \\n\\n \" + n . formatblocks else : #if would be over char limits, we have no choice but to flush the buffer and restart if combined_node_buffer : out_children . append ( combined_node_buffer ) combined_node_buffer = n #set this block as new buffer if combined_node_buffer : out_children . append ( combined_node_buffer ) #flush the buffer one last time return out_children helper special \u00b6 serializers \u00b6 SignedSerializer ( Serializer ) \u00b6 Source code in boltworks/helper/serializers.py class SignedSerializer ( Serializer ): def __init__ ( self , serializer : Serializer , symmetric_key , max_age : Union [ int , None ] = 3600 * 24 * 90 ): self . _signer = itsdangerous . TimestampSigner ( symmetric_key ) if max_age else itsdangerous . Signer ( symmetric_key ) self . _max_age = max_age self . _serializer = serializer def dumps ( self , obj : Any ): serialized = self . _serializer . dumps ( obj ) signed = self . _signer . sign ( serialized ) return signed def loads ( self , signed_serialized : bytes ): unsigned = self . _signer . unsign ( signed_value = signed_serialized , max_age = self . _max_age ) if isinstance ( self . _signer , itsdangerous . TimestampSigner ) else self . _signer . unsign ( signed_value = signed_serialized ) return self . _serializer . loads ( unsigned ) def __getstate__ ( self ): raise Exception ( \"serializing this class is not allowed, for security reasons\" ) __init__ ( self , serializer , symmetric_key , max_age = 7776000 ) special \u00b6 Initialize self. See help(type(self)) for accurate signature. Source code in boltworks/helper/serializers.py def __init__ ( self , serializer : Serializer , symmetric_key , max_age : Union [ int , None ] = 3600 * 24 * 90 ): self . _signer = itsdangerous . TimestampSigner ( symmetric_key ) if max_age else itsdangerous . Signer ( symmetric_key ) self . _max_age = max_age self . _serializer = serializer","title":"modules"},{"location":"api/#boltworks.boltworks","text":"Main module.","title":"boltworks"},{"location":"api/#boltworks.cli","text":"","title":"cli"},{"location":"api/#boltworks.cli.argparse_decorator","text":"","title":"argparse_decorator"},{"location":"api/#boltworks.cli.argparse_decorator.argparse_command","text":"This is the primary method for this feature. It is a decorator that you put onto your Slack Command Method to parse the arguments in the command and pass them to your function. You can either construct an argparse.ArgumentParser yourself to do the work (better) Or set automagic=True to have a simple ArgumentParser constructed for you based on your method signature (faster) Any parameter names in your method signature which Slack would usually inject (eg 'args' or 'say' or 'logger' etc) will be passed through. 1 2 3 4 5 6 7 8 9 10 argparser = argparse.ArgumentParser() argparser.add_argument(\"--a\", nargs=\"*\", type=float) argparser.add_argument(\"-b\", type=int) argparser.add_argument(\"c\") argparser.add_argument(\"d\", nargs=\"?\", default=\"default\") @app.command(\"/dothething\") @argparse_command(parser) def your_method_name(args:Args, say, a, b, c, d): ... can be called as /dothething cc dd --a 1 2 3 -b 5 In automagic mode, to have a parameter be called as --foo, make it KeywordOnly by placing it after a single asterisk. Otherwise the argument name is silent 1 2 3 4 @app.command(\"/dotheotherthing\") @argparse_command(automagic=True) def your_method_name(args:Args, say, a:str, b:list[int], *, c:int, d:int): ... can be called as /dotheotherthing test 1 2 3 --d 6 --c 5 (You are allowed to use Automagic together with an ArgumentParser as well to fill in an extra arg not handled by the parser) In both cases, the argparser library will always insert a --help parameter, though it will be better documented if you build your own ArgumentParser. It's recommended when you configure the Command in Slack to configure the usage string as [--help] to let people know they can do that. Parameters: Name Type Description Default argparser Optional[ArgumentParser] An optional argparse.ArgumentParser object with which to parse the arguments None echo_back bool description . Defaults to True. Calls 'say' to echo back the command executed to the user before executing it. True do_ack bool description . Defaults to True. Calls Slack's ack() method for you upon succesful parsing, so you don't have to do it yourself. True automagic bool description . Defaults to False. Enables automagic parsing of arguments based on your method signature. Only supported on Python>=3.9 False Exceptions: Type Description ValueError various ValueErrors can be raised, generally at the time of creation of the argparse_handler Source code in boltworks/cli/argparse_decorator.py def argparse_command ( argparser : Optional [ ArgumentParser ] = None , echo_back = True , do_ack = True , automagic = False ): \"\"\" This is the primary method for this feature. It is a decorator that you put onto your Slack Command Method to parse the arguments in the command and pass them to your function. You can either construct an argparse.ArgumentParser yourself to do the work (better) Or set automagic=True to have a simple ArgumentParser constructed for you based on your method signature (faster) Any parameter names in your method signature which Slack would usually inject (eg 'args' or 'say' or 'logger' etc) will be passed through. ``` argparser = argparse.ArgumentParser() argparser.add_argument(\"--a\", nargs=\"*\", type=float) argparser.add_argument(\"-b\", type=int) argparser.add_argument(\"c\") argparser.add_argument(\"d\", nargs=\"?\", default=\"default\") @app.command(\"/dothething\") @argparse_command(parser) def your_method_name(args:Args, say, a, b, c, d): ... ``` can be called as `/dothething cc dd --a 1 2 3 -b 5` In automagic mode, to have a parameter be called as --foo, make it KeywordOnly by placing it after a single asterisk. Otherwise the argument name is silent ``` @app.command(\"/dotheotherthing\") @argparse_command(automagic=True) def your_method_name(args:Args, say, a:str, b:list[int], *, c:int, d:int): ... ``` can be called as `/dotheotherthing test 1 2 3 --d 6 --c 5` (You are allowed to use Automagic together with an ArgumentParser as well to fill in an extra arg not handled by the parser) In both cases, the argparser library will always insert a `--help` parameter, though it will be better documented if you build your own ArgumentParser. It's recommended when you configure the Command in Slack to configure the usage string as `[--help]` to let people know they can do that. Args: argparser (Optional[ArgumentParser]): An optional argparse.ArgumentParser object with which to parse the arguments echo_back (bool, optional): _description_. Defaults to True. Calls 'say' to echo back the command executed to the user before executing it. do_ack (bool, optional): _description_. Defaults to True. Calls Slack's ack() method for you upon succesful parsing, so you don't have to do it yourself. automagic (bool, optional): _description_. Defaults to False. Enables automagic parsing of arguments based on your method signature. Only supported on Python>=3.9 Raises: ValueError: various ValueErrors can be raised, generally at the time of creation of the argparse_handler * If there are conflicts between slack-reserved argnames and your argparser names * If you don't have automagic set to True and don't pass an ArgumentParser, or the ArgumentParser doesn't handle all your method's params * If you use automagic, but don't sufficiently type-hint your parameters, or the types are too complicated etc. \"\"\" if not argparser : if not automagic : raise ValueError ( \"If you don't pass in an argparser, you must set automagic to True\" ) argparser = ArgumentParser () if automagic and sys . version_info < ( 3 , 9 ): raise ValueError ( \"automagic mode is not supported on Python versions < 3.9\" ) argparser_dests = [ a . dest for a in argparser . _actions if a . dest != \"help\" ] argname_conflicts = [ dest for dest in argparser_dests if dest in RESERVED_SLACK_ARGS ] if argname_conflicts : raise ValueError ( f \"One or more dest param names in your argparser conflict with built in param names used by slack bolt: { ', ' . join ( argname_conflicts ) } \\n Try setting the `dest` argument for those argparser actions to something else\" ) # if \"args\" in argparser_dests: # raise ValueError(f\"The 'args' param name is reserved for Slack, so you can't use it for an argparser argument name.\\nTry setting `the` dest parameter for that action to something else\") def _mid_func ( decorated_function ): midfunc_argparser = argparser deco_sig = inspect . signature ( decorated_function ) deco_argnames = [ a . name for a in deco_sig . parameters . values ()] deco_varargs = [ a . name for a in deco_sig . parameters . values () if a . kind == a . VAR_POSITIONAL ] if deco_varargs : raise ValueError ( f \"There is a varargs `* { deco_varargs [ 0 ] } ` in the method signature of the method you are decorating, which is unsupported. Please use a list instead\" ) deco_varkwargs = [ a . name for a in deco_sig . parameters . values () if a . kind == a . VAR_KEYWORD ] if not deco_varkwargs : #if there is no **kwargs to handle extra arguments... unhandled_arguments = [ dest for dest in argparser_dests if dest not in deco_argnames ] if unhandled_arguments : raise ValueError ( f \"The argparser object you provided generates one or more arguments ( { ',' . join ( unhandled_arguments ) } ) which are unhandled by the method you are decorating, nor does your method does not have a **kwargs to absorb them\" ) deco_extra_args_in_deco = [ a for a in deco_sig . parameters . values () if a . kind is not a . VAR_KEYWORD and a . name not in RESERVED_SLACK_ARGS and a . name not in argparser_dests ] deco_extra_args_in_deco_without_defaults = [ a for a in deco_extra_args_in_deco if a . default is a . empty ] if not automagic and deco_extra_args_in_deco_without_defaults : raise ValueError ( f \"The method you are decorating has one or more parameters without defaults defined that your argparser is not set to fill: { ',' . join ( deco_extra_args_in_deco ) } \" ) if automagic and deco_extra_args_in_deco : midfunc_argparser = automagically_add_args_to_argparser ( decorated_function , midfunc_argparser , deco_extra_args_in_deco ) def _inner_func_to_return_to_slack ( args : Args ): def fn ( message , file = None ): safe_post_in_blockquotes ( args . respond , message ) args . ack () innerfunc_argparser = copy . deepcopy ( midfunc_argparser ) #so we can have _print_message be unique to each call innerfunc_argparser . formatter_class = SlackArgParseFormatter innerfunc_argparser . _print_message = fn if args . command : command_base = args . command [ 'command' ] . replace ( \"*\" , \"\" ) if 'command' in args . command else '<cmd>' command_args = shlex . split ( args . command [ 'text' ] . replace ( \"*\" , \"\" )) if 'text' in args . command else [] elif args . message : split_message = shlex . split ( args . message [ 'text' ] . replace ( \"*\" , \"\" )) command_base = split_message [ 0 ] command_args = split_message [ 1 :] else : raise Exception ( \"This class is only to be used with @command or @message\" ) # unfortunately it's not possible to perfectly strip out the markup formatting so for now we are just stripping out asterisks # whenever they add 'blocks' to the command response, we can parse that to get the exact plaintext representation # see also https://stackoverflow.com/a/70627214/10773089 innerfunc_argparser . prog = command_base #maybe add more verbose explanation if you use `--var`` when it should have been `var`, or vice versa parsed_params = vars ( innerfunc_argparser . parse_args ( command_args )) if do_ack : args . ack () if echo_back : args . say ( text = f \"* { command_base } { ( shlex . join ( command_args )) } * \\t (run by <@ { args . context [ 'user_id' ] } >)\" ) available_slackvars_to_pass = { 'args' : args , ** vars ( args )} if deco_varkwargs : #if there's a varkwargs then just pass everything slackvars_to_pass = available_slackvars_to_pass else : slackvars_to_pass = { k : v for k , v in available_slackvars_to_pass . items () if k in deco_argnames } return decorated_function ( ** slackvars_to_pass , ** parsed_params ) return _inner_func_to_return_to_slack #on init, it will return a function that does all the above stuff when run return _mid_func","title":"argparse_command()"},{"location":"api/#boltworks.gui","text":"","title":"gui"},{"location":"api/#boltworks.gui.expandpointer","text":"","title":"expandpointer"},{"location":"api/#boltworks.gui.expandpointer.ExpandPointer","text":"An ExpandPointer is a series of indexes into a Node Tree which recursively indicates which nodes to expand. This class is just a wrapper around Tuple. It exists as a seperate class mostly to avoid the somewhat more confusing tuple syntax for tuple literals. Source code in boltworks/gui/expandpointer.py class ExpandPointer : \"\"\" An ExpandPointer is a series of indexes into a Node Tree which recursively indicates which nodes to expand. This class is just a wrapper around Tuple. It exists as a seperate class mostly to avoid the somewhat more confusing tuple syntax for tuple literals. \"\"\" def __init__ ( self , values : Iterable [ int ]) -> None : self . _values : Tuple [ int , ... ] = tuple ( values ) @overload def __getitem__ ( self , index : int ) -> int : ... @overload def __getitem__ ( self , index : slice ) -> ExpandPointer : ... def __getitem__ ( self , index : Union [ int , slice ]) -> Union [ int , ExpandPointer ]: if isinstance ( index , int ): return self . _values [ index ] elif isinstance ( index , slice ): return ExpandPointer ( self . _values [ index ]) else : raise TypeError ( 'Index must be an int or slice' ) def __hash__ ( self ) -> int : return self . _values . __hash__ () def __len__ ( self ) -> int : return self . _values . __len__ () def __iter__ ( self ): return self . _values . __iter__ () def append ( self , val : int ) -> ExpandPointer : return ExpandPointer ( self . _values + ( val ,)) def extend ( self , obj : Iterable [ int ]) -> ExpandPointer : return ExpandPointer ( self . _values + tuple ( obj )) def __getstate__ ( self ): return self . _values def __setstate__ ( self , state ): self . _values = state","title":"ExpandPointer"},{"location":"api/#boltworks.gui.treenodeui","text":"","title":"treenodeui"},{"location":"api/#boltworks.gui.treenodeui.ButtonChildContainer","text":"The most basic child node container, this represents a button Parameters: Name Type Description Default ChildNodeContainer _type_ description required Source code in boltworks/gui/treenodeui.py class ButtonChildContainer ( ChildNodeContainer ): \"\"\"The most basic child node container, this represents a button Args: ChildNodeContainer (_type_): _description_ \"\"\" def __init__ ( self , child_nodes : list [ TreeNode ], expand_button_format_string : str = NAMELESS_FMT_STR_EXPAND , collapse_button_format_string : str = NAMELESS_FMT_STR_COLLAPSE , static_button_text : Optional [ str ] = None , child_pageination : int = 10 ): self . child_nodes = child_nodes self . expand_button_format_string = expand_button_format_string if not static_button_text else static_button_text self . collapse_button_format_string = collapse_button_format_string if not static_button_text else static_button_text self . child_pageination = child_pageination def format_container ( self , rootkey : str , pointer_to_container : ExpandPointer , child_already_selected : int =- 1 ) -> InteractiveElement : if child_already_selected == - 1 : #if not already selected then it should be an expand button return TreeNodeUI . _button_to_replace_block ( rootkey = rootkey , expandpointer = pointer_to_container . append ( 0 ) #appending 0 to point to first node contained within this button , button_text = self . expand_button_format_string . format ( len ( self . child_nodes ))) else : return TreeNodeUI . _button_to_replace_block ( rootkey = rootkey , expandpointer = pointer_to_container [: - 1 ] #slicing off the last one to collapse this container and only show it's containing node , button_text = self . collapse_button_format_string . format ( len ( self . child_nodes )), style = \"danger\" ) @staticmethod def forJsonDetails ( jsonlike : list | dict , name : str = \"details\" , pageination = 15 , optimize_blocks = True ): children , numchildren = _jsonlike_to_treenode_and_truenum_children ( jsonlike , optimize_blocks = optimize_blocks , _level = 0 , pageination = pageination ) return ButtonChildContainer ( children , expand_button_format_string = name . format ( numchildren ) if name else NAMELESS_FMT_STR_EXPAND . format ( numchildren ), collapse_button_format_string = name . format ( numchildren ) if name else NAMELESS_FMT_STR_COLLAPSE . format ( numchildren ), child_pageination = pageination )","title":"ButtonChildContainer"},{"location":"api/#boltworks.gui.treenodeui.TreeNode","text":"The basic building block of this UI library, a Node has it's own Blocks, under formatblocks, and optionally, one or more child_containers containing one or more child nodes which can be expanded If there is only one childNodeContainer it will by default be placed on the side of the first formatblock If there is more than one, they will by default be placed on their own row, after the formatblocks This behavior can be overriden with the first_child_container_on_side param Source code in boltworks/gui/treenodeui.py class TreeNode : \"\"\"The basic building block of this UI library, a Node has it's own Blocks, under formatblocks, and optionally, one or more child_containers containing one or more child nodes which can be expanded If there is only one childNodeContainer it will by default be placed on the side of the first formatblock If there is more than one, they will by default be placed on their own row, after the formatblocks This behavior can be overriden with the `first_child_container_on_side` param \"\"\" def __init__ ( self , formatblocks : Union [ list [ Block ], Block , str ], children_containers : ChildNodeContainer | ChildNodeMenuContainer | list [ ChildNodeContainer | ChildNodeMenuContainer ] | None = None , first_child_container_on_side : Optional [ bool ] = None , auto_expand_children_if_only_one = False ): \"\"\"_summary_ Args: formatblocks (Union[list[Block],Block,str]): The formatting blocks for the node children_containers (ChildNodeContainer | ChildNodeMenuContainer | list[ChildNodeContainer | ChildNodeMenuContainer], optional): The whole point of the UI: these are interactive elements which if clicked/selected, will expand their child nodes underneath the node first_child_container_on_side (bool, optional): This overrides the default behavior, which is to put the first childNodeContainer on the side of the first formatting block IF it is the only childNodeContainer auto_expand_children_if_only_one (bool, optional): This option is deprecated and may be removed. It forces expand for any child that itself only has a single child node. Defaults to False. \"\"\" self . formatblocks = formatblocks self . children_containers = children_containers if isinstance ( children_containers , list ) else [ children_containers ] if children_containers else [] if first_child_container_on_side is not None : self . first_child_container_on_side = first_child_container_on_side # override else : self . first_child_container_on_side = len ( self . children_containers ) == 1 # default behavior for side placement self . auto_expand_children_if_only_one = auto_expand_children_if_only_one #delete? def __repr__ ( self ): toreturn = f \" { type ( self ) } \" if self . children_containers : toreturn += f \"( { len ( self . children_containers ) } children_containers, total grandchildren_nodes { sum ( len ( cc . child_nodes ) for cc in self . children_containers ) } ) \" toreturn += \": \" if isinstance ( self . formatblocks , str ): toreturn += self . formatblocks elif isinstance ( self . formatblocks , SectionBlock ): toreturn += self . formatblocks . text . text elif isinstance ( self . formatblocks , list ): toreturn += \" \\n \" . join ([ b . text . text if isinstance ( b , SectionBlock ) and b . text else b . to_dict () for b in self . formatblocks ]) return toreturn def text_formatting_as_str ( n ): #best try basis, not guaranteed to return correctly if isinstance ( n . formatblocks , str ): return n . formatblocks elif isinstance ( n . formatblocks , SectionBlock ): return n . formatblocks . text . text elif isinstance ( n . formatblocks , list ): return \" \\n \" . join ([ fb . text . text for fb in n . formatblocks if 'text' in fb . attributes ]) else : return \"\" #or raise exception?? @staticmethod def withSimpleSideButton ( formatblocks : Union [ list [ Block ], Block , str ], children : list [ TreeNode ] = [], expand_button_format_string : str = NAMELESS_FMT_STR_EXPAND , collapse_button_format_string : str = NAMELESS_FMT_STR_COLLAPSE , child_pageination : int = 10 ) -> TreeNode : \"\"\"A simple way to get a basic node with a side button expanding its children Args: formatblocks (Union[list[Block],Block,str]): the formatting blocks for the node itself children (list[TreeNode], optional): any children for the node expand_button_format_string (str, optional): a string for the side button if any, when it is not yet expanded, if {} is in the string, it will be replaced with the number of children collapse_button_format_string (str, optional): a string for the side button if any, when it is already expanded, if {} is in the string, it will be replaced with the number of children child_pageination (int, optional): _description_. Defaults to 10. Returns: TreeNode: the treenode requested \"\"\" return TreeNode ( formatblocks ,[ ButtonChildContainer ( children , expand_button_format_string , collapse_button_format_string , child_pageination = child_pageination )] if children else []) @staticmethod def fromJson ( formatblocks : Union [ str , Block , list [ Block ]], jsonlike : Union [ list , dict ], pageination = 15 , optimize_blocks = True ): return TreeNode ( formatblocks ,[ ButtonChildContainer . forJsonDetails ( jsonlike , \"details\" , pageination , optimize_blocks )])","title":"TreeNode"},{"location":"api/#boltworks.gui.treenodeui.TreeNode.__init__","text":"summary Parameters: Name Type Description Default formatblocks Union[list[Block],Block,str] The formatting blocks for the node required children_containers ChildNodeContainer | ChildNodeMenuContainer | list[ChildNodeContainer | ChildNodeMenuContainer] The whole point of the UI: these are interactive elements which if clicked/selected, will expand their child nodes underneath the node None first_child_container_on_side bool This overrides the default behavior, which is to put the first childNodeContainer on the side of the first formatting block IF it is the only childNodeContainer None auto_expand_children_if_only_one bool This option is deprecated and may be removed. It forces expand for any child that itself only has a single child node. Defaults to False. False Source code in boltworks/gui/treenodeui.py def __init__ ( self , formatblocks : Union [ list [ Block ], Block , str ], children_containers : ChildNodeContainer | ChildNodeMenuContainer | list [ ChildNodeContainer | ChildNodeMenuContainer ] | None = None , first_child_container_on_side : Optional [ bool ] = None , auto_expand_children_if_only_one = False ): \"\"\"_summary_ Args: formatblocks (Union[list[Block],Block,str]): The formatting blocks for the node children_containers (ChildNodeContainer | ChildNodeMenuContainer | list[ChildNodeContainer | ChildNodeMenuContainer], optional): The whole point of the UI: these are interactive elements which if clicked/selected, will expand their child nodes underneath the node first_child_container_on_side (bool, optional): This overrides the default behavior, which is to put the first childNodeContainer on the side of the first formatting block IF it is the only childNodeContainer auto_expand_children_if_only_one (bool, optional): This option is deprecated and may be removed. It forces expand for any child that itself only has a single child node. Defaults to False. \"\"\" self . formatblocks = formatblocks self . children_containers = children_containers if isinstance ( children_containers , list ) else [ children_containers ] if children_containers else [] if first_child_container_on_side is not None : self . first_child_container_on_side = first_child_container_on_side # override else : self . first_child_container_on_side = len ( self . children_containers ) == 1 # default behavior for side placement self . auto_expand_children_if_only_one = auto_expand_children_if_only_one #delete?","title":"__init__()"},{"location":"api/#boltworks.gui.treenodeui.TreeNode.withSimpleSideButton","text":"A simple way to get a basic node with a side button expanding its children Parameters: Name Type Description Default formatblocks Union[list[Block],Block,str] the formatting blocks for the node itself required children list[TreeNode] any children for the node [] expand_button_format_string str a string for the side button if any, when it is not yet expanded, if {} is in the string, it will be replaced with the number of children 'expand {}' collapse_button_format_string str a string for the side button if any, when it is already expanded, if {} is in the string, it will be replaced with the number of children 'collapse {}' child_pageination int description . Defaults to 10. 10 Returns: Type Description TreeNode the treenode requested Source code in boltworks/gui/treenodeui.py @staticmethod def withSimpleSideButton ( formatblocks : Union [ list [ Block ], Block , str ], children : list [ TreeNode ] = [], expand_button_format_string : str = NAMELESS_FMT_STR_EXPAND , collapse_button_format_string : str = NAMELESS_FMT_STR_COLLAPSE , child_pageination : int = 10 ) -> TreeNode : \"\"\"A simple way to get a basic node with a side button expanding its children Args: formatblocks (Union[list[Block],Block,str]): the formatting blocks for the node itself children (list[TreeNode], optional): any children for the node expand_button_format_string (str, optional): a string for the side button if any, when it is not yet expanded, if {} is in the string, it will be replaced with the number of children collapse_button_format_string (str, optional): a string for the side button if any, when it is already expanded, if {} is in the string, it will be replaced with the number of children child_pageination (int, optional): _description_. Defaults to 10. Returns: TreeNode: the treenode requested \"\"\" return TreeNode ( formatblocks ,[ ButtonChildContainer ( children , expand_button_format_string , collapse_button_format_string , child_pageination = child_pageination )] if children else [])","title":"withSimpleSideButton()"},{"location":"api/#boltworks.gui.treenodeui.TreeNodeUI","text":"Source code in boltworks/gui/treenodeui.py class TreeNodeUI : def __init__ ( self , app : App , kvstore : KVStore ) -> None : \"\"\"This is the managing class for the NodeUI, which handles posting nodes and then responding to InteractiveElements to expand/contract node children Args: app (App): A Slack Bolt App instance, for posting and registering actionhandlers kvstore (_type_): a KVStore instance, for storing and looking up Nodes \"\"\" app . action ( re . compile ( f \" { prefix_for_callback } .*\" ))( self . _do_callback_action ) self . expiring_root_dict = ExpiringDict ( max_age_seconds = 120 , max_len = 20 ) self . kvstore = kvstore #.namespaced(prefix_for_callback) self . _slack_chat_client = app . client def post_single_node ( self , post_callable_or_channel : str | Say | Respond , node : TreeNode , alt_text : str = None , expand_first : bool = False ): \"\"\"Posts a Single Node Args: post_callable_or_channel: either an instance of Respond or Say, or a channelid to post to node (TreeNode): the node to post alt_text (str, optional): for notifications that require a simple string expand_first (bool, optional): if set to True, the Node will post with its first child container expanded [to its first menu option] \"\"\" say = Say ( self . _slack_chat_client , post_callable_or_channel ) if isinstance ( post_callable_or_channel , str ) else post_callable_or_channel rootkey = self . _rootkey_from_treenode ( node ) return say ( text = alt_text or node . text_formatting_as_str (), blocks = self . _format_tree ( rootkey , expand_first = expand_first ), unfurl_links = False ) def post_treenodes ( self , post_callable_or_channel : str | Say | Respond , treenodes : list [ TreeNode ], post_all_together : bool , global_header : str = None , * , message_if_none : str = None , expand_first_if_seperate = False , ** other_global_tn_kwargs ): \"\"\"Posts multiple Nodes together Args: post_callable_or_channel (Union[PostMethod,str]): either an instance of Respond or Say, or a channelid to post to treenodes (list[TreeNode]): the nodes to post post_all_together (bool): if True, will collect the nodes under a parent node so they can all be collapsed together to save space global_header (str, optional): if posting together, this will be the text of the parent node, otherwise just a header posted before the nodes message_if_none (str, optional): optionally, provide a string to post if there are no nodes expand_first_if_seperate (bool, optional): like expand_first for post_single_node, only effective if posting the blocks seperately \"\"\" say = Say ( self . _slack_chat_client , post_callable_or_channel ) if isinstance ( post_callable_or_channel , str ) else post_callable_or_channel if not treenodes : if message_if_none : say ( message_if_none ) return if post_all_together : num_treenodes = f \" ( { len ( treenodes ) } ) \" if len ( treenodes ) > 1 else \"\" alt_text = f \" { global_header } : { num_treenodes } { treenodes [ 0 ] . text_formatting_as_str () } \" say ( text = alt_text , blocks = self . _format_tree ( self . _rootkey_from_treenode ( TreeNode . withSimpleSideButton ( formatblocks = global_header if global_header else [], children = treenodes , ** other_global_tn_kwargs )), expand_first = True ), unfurl_links = False ) else : if global_header : say ( text = global_header ) for node in treenodes : rootkey = self . _rootkey_from_treenode ( node ) alt_text = node . text_formatting_as_str () say ( text = alt_text , blocks = self . _format_tree ( rootkey , expand_first = expand_first_if_seperate ), unfurl_links = False ) def _rootkey_from_treenode ( self , node : TreeNode ): rootkey = str ( uuid1 ()) self . kvstore [ rootkey ] = node self . expiring_root_dict [ rootkey ] = node return rootkey def _get_root ( self , rootkey : str ) -> TreeNode : if rootkey in self . expiring_root_dict : return self . expiring_root_dict [ rootkey ] root = self . kvstore [ rootkey ] self . expiring_root_dict [ rootkey ] = root return root def _do_callback_action ( self , ack , action , respond ): # if logging.root.level<=logging.DEBUG: # self.profiler.start() ack () #find a way of threading that maybe? callback_data = action [ 'action_id' ][ len ( prefix_for_callback ):] rootkey , expandpointer = self . _deserialize_callback ( callback_data ) value = action [ 'selected_option' ][ 'value' ] if 'selected_option' in action and 'value' in action [ 'selected_option' ] else None if value : if int ( value ) == - 1 : #deselect expandpointer = expandpointer [: - 1 ] else : expandpointer = expandpointer . extend ([ int ( value ), 0 ]) blocks = self . _format_tree ( rootkey , expandpointer = expandpointer ) response = respond ( replace_original = True , blocks = blocks ) if isinstance ( response , WebhookResponse ): if response . status_code != 200 : respond ( f \"error in slack handling: { response . body } \" , replace_original = False ) print ( f \" { datetime . datetime . now () } : error in slack handling: { response . body } \" ) return response # if logging.root.level<=logging.DEBUG: # self.profiler.stop() # print(self.profiler.output_text(unicode=True, color=True)) @staticmethod def _button_to_replace_block ( button_text : str , rootkey : str , expandpointer : ExpandPointer , ** format_options ): serialized_data = TreeNodeUI . _serialize_callback ( rootkey , expandpointer ) button = ButtonElement ( text = button_text , action_id = f \" { serialized_data } \" , ** format_options ) return button @staticmethod def _serialize_callback ( rootkey : str , expandpointer : ExpandPointer ) -> str : serialized_pointer = ',' . join ([ str ( v ) for v in expandpointer ]) return f \" { prefix_for_callback }{ rootkey } ^ { serialized_pointer } \" @staticmethod def _deserialize_callback ( data : str ) -> Tuple [ str , ExpandPointer ]: rootkey , serialized_pointer = data . rsplit ( '^' , 1 ) pointerelems = serialized_pointer . split ( ',' ) expandpointer = ExpandPointer ([ int ( p ) for p in pointerelems ]) return rootkey , expandpointer def _format_tree ( self , rootkey : str , * , expandpointer : ExpandPointer = ExpandPointer ([ 0 ]), expand_first = False ): root = self . _get_root ( rootkey ) if expand_first and root . children_containers : if isinstance ( root . children_containers [ 0 ], ChildNodeContainer ): expandpointer = ExpandPointer ([ 0 , 0 , 0 ]) elif isinstance ( root . children_containers [ 0 ], ChildNodeMenuContainer ): expandpointer = ExpandPointer ([ 0 , 0 , 0 , 0 ]) diminish_pageination_by = 0 blocks_to_return = self . _format_tree_recursive ( parentnodes = [ root ], expandpointer = expandpointer , ancestral_pointer = ExpandPointer ([]), rootkey = rootkey , parents_pagination = 1 , diminish_pageination_by = 0 ) if len ( blocks_to_return ) > 50 : #this could probably be made more efficient, but for now, this should suffice while len ( blocks_to_return ) > 49 : diminish_pageination_by += 1 blocks_to_return = self . _format_tree_recursive ( parentnodes = [ root ], expandpointer = expandpointer , ancestral_pointer = ExpandPointer ([]), rootkey = rootkey , parents_pagination = 1 , diminish_pageination_by = diminish_pageination_by ) blocks_to_return . append ( ContextBlock ( elements = [ MarkdownTextObject ( text = \"(blocks were repaginated to avoid exceeding slack limits)\" )])) return blocks_to_return def _format_tree_recursive ( self , parentnodes : list [ TreeNode ], expandpointer : ExpandPointer , #:list[int], #could just make last one the start_at pointer and only go deeper if theres more ancestral_pointer : ExpandPointer , rootkey : str , parents_pagination : int = 10 , diminish_pageination_by = 0 #in case we exceed block limits, we can retry with some number here to recursively diminish the pageination ) -> list [ Block ]: parents_pagination = parents_pagination if not diminish_pageination_by else max ( 1 , parents_pagination - diminish_pageination_by ) child_insert , remaining_expandpointer = expandpointer [ 0 ], expandpointer [ 1 :] num_parents = len ( parentnodes ) start_at = self . _startat ( child_insert , parents_pagination ) end_at = self . _endat ( start_at , parents_pagination , num_parents ) blocks : list [ Block ] = [] before_blocks = [ blocks for number , node in enumerate ( parentnodes [ start_at : child_insert ], start_at ) for blocks in self . _formatblock ( node , ancestral_pointer . append ( number ), rootkey )] blocks . extend ( before_blocks ) blocks_for_pointed_node = self . _formatblock ( parentnodes [ child_insert ], ancestral_pointer . append ( child_insert ), rootkey , remaining_expandpointer ) blocks . extend ( blocks_for_pointed_node ) if remaining_expandpointer : #if there are more nodes to expand in the pointer list new_parent = parentnodes [ child_insert ] children_containers = new_parent . children_containers if remaining_expandpointer [ 0 ] > len ( new_parent . children_containers ): #transitional remaining_expandpointer = ExpandPointer ([ 0 , 0 ]) if len ( remaining_expandpointer ) == 1 : #transitional remaining_expandpointer = ExpandPointer ([ 0 ]) . extend ( remaining_expandpointer ) container_opened_index = remaining_expandpointer [ 0 ] selected_container = children_containers [ container_opened_index ] if isinstance ( selected_container , ChildNodeContainer ): selected_container_blocks = self . _format_tree_recursive ( parentnodes = selected_container . child_nodes if selected_container . child_nodes else [ TreeNode ( \"_(this pane is empty)_\" )], parents_pagination = selected_container . child_pageination , expandpointer = remaining_expandpointer [ 1 :], ancestral_pointer = ancestral_pointer . append ( child_insert ) . append ( remaining_expandpointer [ 0 ]), rootkey = rootkey , diminish_pageination_by = diminish_pageination_by ) else : assert isinstance ( selected_container , ChildNodeMenuContainer ) selected_container_blocks = self . _format_tree_recursive ( parentnodes = selected_container . child_nodes [ remaining_expandpointer [ 1 ]] if selected_container . child_nodes and selected_container . child_nodes [ remaining_expandpointer [ 1 ]] else [ TreeNode ( \"_(this pane is empty)_\" )], parents_pagination = selected_container . child_pageination , expandpointer = remaining_expandpointer [ 2 :], #since this contains multiple lists of nodes, we need two pointer indexes to find the next node to show ancestral_pointer = ancestral_pointer . append ( child_insert ) . append ( remaining_expandpointer [ 0 ]) . append ( remaining_expandpointer [ 1 ]), rootkey = rootkey , diminish_pageination_by = diminish_pageination_by ) blocks . extend ( selected_container_blocks ) after_blocks = [ blocks for number , node in enumerate ( parentnodes [ child_insert + 1 : end_at ], child_insert + 1 ) for blocks in self . _formatblock ( node , ancestral_pointer . append ( number ), rootkey )] blocks . extend ( after_blocks ) navig_blocks = self . _make_prev_next_buttons ( usePrev = start_at > 0 , useNext = end_at < num_parents , prev_callback = ( rootkey , ancestral_pointer . append ( start_at - parents_pagination if start_at - parents_pagination > 0 else 0 )), next_callback = ( rootkey , ancestral_pointer . append ( start_at + parents_pagination ))) #if startat+parents_per_page<num_parents else 0 if navig_blocks : blocks . append ( navig_blocks ) return blocks def _formatblock ( self , node : TreeNode , pointer_to_block : ExpandPointer , rootkey : str , remaining_expandpointer : ExpandPointer = None ): blocks : list [ Block ] = [] if isinstance ( node . formatblocks , list ): blocks . extend ( node . formatblocks ) elif isinstance ( node . formatblocks , Block ): blocks . append ( node . formatblocks ) elif isinstance ( node . formatblocks , str ) and node . formatblocks : blocks . append ( simple_slack_block ( node . formatblocks )) def format_nth_container ( n ): if not remaining_expandpointer or remaining_expandpointer [ 0 ] != n : return node . children_containers [ n ] . format_container ( rootkey , pointer_to_block . append ( n ), - 1 ) else : child_selected = remaining_expandpointer [ 1 ] if isinstance ( node . children_containers [ n ], ChildNodeMenuContainer ) and len ( remaining_expandpointer ) > 1 else 0 return node . children_containers [ n ] . format_container ( rootkey , pointer_to_block . append ( n ), child_selected ) if node . children_containers : if node . first_child_container_on_side and blocks and 'accessory' in blocks [ 0 ] . attributes : #and not blocks[0].accessory blocks [ 0 ] . accessory = format_nth_container ( 0 ) # type: ignore start_at = 1 else : start_at = 0 after_blocks_container_elements = ( format_nth_container ( n ) for n in range ( start_at , len ( node . children_containers ))) blocks . extend ( ActionsBlock ( elements = buttons_chunk ) for buttons_chunk in chunked ( after_blocks_container_elements , ActionsBlock . elements_max_length )) return blocks def _make_prev_next_buttons ( self , usePrev : bool , useNext : bool , prev_callback : Tuple [ str , ExpandPointer ], next_callback : Tuple [ str , ExpandPointer ]) -> Optional [ ActionsBlock ]: if ( not usePrev ) and ( not useNext ): return None buttons = [] if ( usePrev ): buttons . append ( self . _button_to_replace_block ( \":arrow_left:\" , * prev_callback )) if ( useNext ): buttons . append ( self . _button_to_replace_block ( \":arrow_right:\" , * next_callback )) navig_buttons = ActionsBlock ( elements = buttons ) return navig_buttons def _startat ( self , value , pageinate ): mod = value % pageinate return value - mod if value >= pageinate else 0 def _endat ( self , startat , pageinate , length ): return startat + pageinate if startat + pageinate < length else length","title":"TreeNodeUI"},{"location":"api/#boltworks.gui.treenodeui.TreeNodeUI.__init__","text":"This is the managing class for the NodeUI, which handles posting nodes and then responding to InteractiveElements to expand/contract node children Parameters: Name Type Description Default app App A Slack Bolt App instance, for posting and registering actionhandlers required kvstore _type_ a KVStore instance, for storing and looking up Nodes required Source code in boltworks/gui/treenodeui.py def __init__ ( self , app : App , kvstore : KVStore ) -> None : \"\"\"This is the managing class for the NodeUI, which handles posting nodes and then responding to InteractiveElements to expand/contract node children Args: app (App): A Slack Bolt App instance, for posting and registering actionhandlers kvstore (_type_): a KVStore instance, for storing and looking up Nodes \"\"\" app . action ( re . compile ( f \" { prefix_for_callback } .*\" ))( self . _do_callback_action ) self . expiring_root_dict = ExpiringDict ( max_age_seconds = 120 , max_len = 20 ) self . kvstore = kvstore #.namespaced(prefix_for_callback) self . _slack_chat_client = app . client","title":"__init__()"},{"location":"api/#boltworks.gui.treenodeui.TreeNodeUI.post_single_node","text":"Posts a Single Node Parameters: Name Type Description Default post_callable_or_channel str | Say | Respond either an instance of Respond or Say, or a channelid to post to required node TreeNode the node to post required alt_text str for notifications that require a simple string None expand_first bool if set to True, the Node will post with its first child container expanded [to its first menu option] False Source code in boltworks/gui/treenodeui.py def post_single_node ( self , post_callable_or_channel : str | Say | Respond , node : TreeNode , alt_text : str = None , expand_first : bool = False ): \"\"\"Posts a Single Node Args: post_callable_or_channel: either an instance of Respond or Say, or a channelid to post to node (TreeNode): the node to post alt_text (str, optional): for notifications that require a simple string expand_first (bool, optional): if set to True, the Node will post with its first child container expanded [to its first menu option] \"\"\" say = Say ( self . _slack_chat_client , post_callable_or_channel ) if isinstance ( post_callable_or_channel , str ) else post_callable_or_channel rootkey = self . _rootkey_from_treenode ( node ) return say ( text = alt_text or node . text_formatting_as_str (), blocks = self . _format_tree ( rootkey , expand_first = expand_first ), unfurl_links = False )","title":"post_single_node()"},{"location":"api/#boltworks.gui.treenodeui.TreeNodeUI.post_treenodes","text":"Posts multiple Nodes together Parameters: Name Type Description Default post_callable_or_channel Union[PostMethod,str] either an instance of Respond or Say, or a channelid to post to required treenodes list[TreeNode] the nodes to post required post_all_together bool if True, will collect the nodes under a parent node so they can all be collapsed together to save space required global_header str if posting together, this will be the text of the parent node, otherwise just a header posted before the nodes None message_if_none str optionally, provide a string to post if there are no nodes None expand_first_if_seperate bool like expand_first for post_single_node, only effective if posting the blocks seperately False Source code in boltworks/gui/treenodeui.py def post_treenodes ( self , post_callable_or_channel : str | Say | Respond , treenodes : list [ TreeNode ], post_all_together : bool , global_header : str = None , * , message_if_none : str = None , expand_first_if_seperate = False , ** other_global_tn_kwargs ): \"\"\"Posts multiple Nodes together Args: post_callable_or_channel (Union[PostMethod,str]): either an instance of Respond or Say, or a channelid to post to treenodes (list[TreeNode]): the nodes to post post_all_together (bool): if True, will collect the nodes under a parent node so they can all be collapsed together to save space global_header (str, optional): if posting together, this will be the text of the parent node, otherwise just a header posted before the nodes message_if_none (str, optional): optionally, provide a string to post if there are no nodes expand_first_if_seperate (bool, optional): like expand_first for post_single_node, only effective if posting the blocks seperately \"\"\" say = Say ( self . _slack_chat_client , post_callable_or_channel ) if isinstance ( post_callable_or_channel , str ) else post_callable_or_channel if not treenodes : if message_if_none : say ( message_if_none ) return if post_all_together : num_treenodes = f \" ( { len ( treenodes ) } ) \" if len ( treenodes ) > 1 else \"\" alt_text = f \" { global_header } : { num_treenodes } { treenodes [ 0 ] . text_formatting_as_str () } \" say ( text = alt_text , blocks = self . _format_tree ( self . _rootkey_from_treenode ( TreeNode . withSimpleSideButton ( formatblocks = global_header if global_header else [], children = treenodes , ** other_global_tn_kwargs )), expand_first = True ), unfurl_links = False ) else : if global_header : say ( text = global_header ) for node in treenodes : rootkey = self . _rootkey_from_treenode ( node ) alt_text = node . text_formatting_as_str () say ( text = alt_text , blocks = self . _format_tree ( rootkey , expand_first = expand_first_if_seperate ), unfurl_links = False )","title":"post_treenodes()"},{"location":"api/#boltworks.gui.treenodeui.slack_block_optimize_treenode","text":"This method will try to reduce the number of formatting blocks used by a list of Treenode, to fit more blocks without pageinating or going over the slack limit of 50 Parameters: Name Type Description Default children list[TreeNode] the nodes to optimize required Returns: Type Description list[TreeNode] a fewer number of nodes, with some adjacent ones combined Source code in boltworks/gui/treenodeui.py def slack_block_optimize_treenode ( children : list [ TreeNode ]) -> list [ TreeNode ]: \"\"\"This method will try to reduce the number of formatting blocks used by a list of Treenode, to fit more blocks without pageinating or going over the slack limit of 50 Args: children (list[TreeNode]): the nodes to optimize Returns: list[TreeNode]: a fewer number of nodes, with some adjacent ones combined \"\"\" if not children : return [] out_children = [] combined_node_buffer = None #will always be either None or a TreeNode with a str as formattingblocks for n in children : if not _is_simple_text_block ( n ) or n . children_containers : #if the nodes have complicated blocks or children if combined_node_buffer : out_children . append ( combined_node_buffer ) #then just flush the buffer combined_node_buffer = None out_children . append ( n ) #and append this node else : #a simple terminal block that we can combine with other ones to optimize block count: if isinstance ( n . formatblocks , SectionBlock ): n . formatblocks = n . formatblocks . text . text if n . formatblocks . text else '' #convert it to using strings elif isinstance ( n . formatblocks , list ) and isinstance ( n . formatblocks [ 0 ], SectionBlock ): n . formatblocks = n . formatblocks [ 0 ] . text . text if n . formatblocks [ 0 ] . text else '' if not combined_node_buffer : #if no buffer, just start one combined_node_buffer = n else : #otherwise add the string to existing combined_tn, assuming it fits in char limits if len ( combined_node_buffer . formatblocks ) + len ( n . formatblocks ) + 2 < 3000 : #slack char limits for a single section block combined_node_buffer . formatblocks += \" \\n\\n \" + n . formatblocks else : #if would be over char limits, we have no choice but to flush the buffer and restart if combined_node_buffer : out_children . append ( combined_node_buffer ) combined_node_buffer = n #set this block as new buffer if combined_node_buffer : out_children . append ( combined_node_buffer ) #flush the buffer one last time return out_children","title":"slack_block_optimize_treenode()"},{"location":"api/#boltworks.helper","text":"","title":"helper"},{"location":"api/#boltworks.helper.serializers","text":"","title":"serializers"},{"location":"api/#boltworks.helper.serializers.SignedSerializer","text":"Source code in boltworks/helper/serializers.py class SignedSerializer ( Serializer ): def __init__ ( self , serializer : Serializer , symmetric_key , max_age : Union [ int , None ] = 3600 * 24 * 90 ): self . _signer = itsdangerous . TimestampSigner ( symmetric_key ) if max_age else itsdangerous . Signer ( symmetric_key ) self . _max_age = max_age self . _serializer = serializer def dumps ( self , obj : Any ): serialized = self . _serializer . dumps ( obj ) signed = self . _signer . sign ( serialized ) return signed def loads ( self , signed_serialized : bytes ): unsigned = self . _signer . unsign ( signed_value = signed_serialized , max_age = self . _max_age ) if isinstance ( self . _signer , itsdangerous . TimestampSigner ) else self . _signer . unsign ( signed_value = signed_serialized ) return self . _serializer . loads ( unsigned ) def __getstate__ ( self ): raise Exception ( \"serializing this class is not allowed, for security reasons\" )","title":"SignedSerializer"},{"location":"api/#boltworks.helper.serializers.SignedSerializer.__init__","text":"Initialize self. See help(type(self)) for accurate signature. Source code in boltworks/helper/serializers.py def __init__ ( self , serializer : Serializer , symmetric_key , max_age : Union [ int , None ] = 3600 * 24 * 90 ): self . _signer = itsdangerous . TimestampSigner ( symmetric_key ) if max_age else itsdangerous . Signer ( symmetric_key ) self . _max_age = max_age self . _serializer = serializer","title":"__init__()"},{"location":"authors/","text":"Credits \u00b6 Development Lead \u00b6 Yaakov Saxon ysaxon@gmail.com Contributors \u00b6 None yet. Why not be the first?","title":"authors"},{"location":"authors/#credits","text":"","title":"Credits"},{"location":"authors/#development-lead","text":"Yaakov Saxon ysaxon@gmail.com","title":"Development Lead"},{"location":"authors/#contributors","text":"None yet. Why not be the first?","title":"Contributors"},{"location":"contributing/","text":"Contributing \u00b6 Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways: Types of Contributions \u00b6 Report Bugs \u00b6 Report bugs at https://github.com/ysaxon/boltworks/issues. If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug. Fix Bugs \u00b6 Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it. Implement Features \u00b6 Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it. Write Documentation \u00b6 Slack Bolt UI Extensions could always use more documentation, whether as part of the official Slack Bolt UI Extensions docs, in docstrings, or even on the web in blog posts, articles, and such. Submit Feedback \u00b6 The best way to send feedback is to file an issue at https://github.com/ysaxon/boltworks/issues. If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :) Get Started! \u00b6 Ready to contribute? Here's how to set up boltworks for local development. Fork the boltworks repo on GitHub. Clone your fork locally 1 $ git clone git@github.com:your_name_here/boltworks.git Ensure poetry is installed. Install dependencies and start your virtualenv: 1 $ poetry install -E test -E doc -E dev Create a branch for local development: 1 $ git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, check that your changes pass the tests, including testing other Python versions, with tox: 1 $ tox Commit your changes and push your branch to GitHub: 1 2 3 $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website. Pull Request Guidelines \u00b6 Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.md. The pull request should work for Python 3.6, 3.7, 3.8, 3.9 and for PyPy. Check https://github.com/ysaxon/boltworks/actions and make sure that the tests pass for all supported Python versions. Tips``` \u00b6 1 $ pytest tests.test_boltworks ```To run a subset of tests. Deploying \u00b6 A reminder for the maintainers on how to deploy. Make sure all your changes are committed (including an entry in HISTORY.md). Then run: 1 2 3 $ poetry patch # possible: major / minor / patch $ git push $ git push --tags Github Actions will then deploy to PyPI if tests pass.","title":"contributing"},{"location":"contributing/#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways:","title":"Contributing"},{"location":"contributing/#types-of-contributions","text":"","title":"Types of Contributions"},{"location":"contributing/#report-bugs","text":"Report bugs at https://github.com/ysaxon/boltworks/issues. If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug.","title":"Report Bugs"},{"location":"contributing/#fix-bugs","text":"Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it.","title":"Fix Bugs"},{"location":"contributing/#implement-features","text":"Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it.","title":"Implement Features"},{"location":"contributing/#write-documentation","text":"Slack Bolt UI Extensions could always use more documentation, whether as part of the official Slack Bolt UI Extensions docs, in docstrings, or even on the web in blog posts, articles, and such.","title":"Write Documentation"},{"location":"contributing/#submit-feedback","text":"The best way to send feedback is to file an issue at https://github.com/ysaxon/boltworks/issues. If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :)","title":"Submit Feedback"},{"location":"contributing/#get-started","text":"Ready to contribute? Here's how to set up boltworks for local development. Fork the boltworks repo on GitHub. Clone your fork locally 1 $ git clone git@github.com:your_name_here/boltworks.git Ensure poetry is installed. Install dependencies and start your virtualenv: 1 $ poetry install -E test -E doc -E dev Create a branch for local development: 1 $ git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, check that your changes pass the tests, including testing other Python versions, with tox: 1 $ tox Commit your changes and push your branch to GitHub: 1 2 3 $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website.","title":"Get Started!"},{"location":"contributing/#pull-request-guidelines","text":"Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.md. The pull request should work for Python 3.6, 3.7, 3.8, 3.9 and for PyPy. Check https://github.com/ysaxon/boltworks/actions and make sure that the tests pass for all supported Python versions.","title":"Pull Request Guidelines"},{"location":"contributing/#tips","text":"1 $ pytest tests.test_boltworks ```To run a subset of tests.","title":"Tips```"},{"location":"contributing/#deploying","text":"A reminder for the maintainers on how to deploy. Make sure all your changes are committed (including an entry in HISTORY.md). Then run: 1 2 3 $ poetry patch # possible: major / minor / patch $ git push $ git push --tags Github Actions will then deploy to PyPI if tests pass.","title":"Deploying"},{"location":"history/","text":"History \u00b6 0.1.0 (2022-05-27) \u00b6 First release on PyPI.","title":"history"},{"location":"history/#history","text":"","title":"History"},{"location":"history/#010-2022-05-27","text":"First release on PyPI.","title":"0.1.0 (2022-05-27)"},{"location":"installation/","text":"Installation \u00b6 Stable release \u00b6 To install Slack Bolt UI Extensions, run this command in your terminal: 1 pip install boltworks This is the preferred method to install Slack Bolt UI Extensions, as it will always install the most recent stable release. If you don't have pip installed, this Python installation guide can guide you through the process. From source \u00b6 The source for Slack Bolt UI Extensions can be downloaded from the Github repo . You can either clone the public repository: 1 git clone git://github.com/ysaxon/boltworks Or download the tarball : 1 curl -OJL https://github.com/ysaxon/boltworks/tarball/master Once you have a copy of the source, you can install it with: 1 pip install .","title":"installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#stable-release","text":"To install Slack Bolt UI Extensions, run this command in your terminal: 1 pip install boltworks This is the preferred method to install Slack Bolt UI Extensions, as it will always install the most recent stable release. If you don't have pip installed, this Python installation guide can guide you through the process.","title":"Stable release"},{"location":"installation/#from-source","text":"The source for Slack Bolt UI Extensions can be downloaded from the Github repo . You can either clone the public repository: 1 git clone git://github.com/ysaxon/boltworks Or download the tarball : 1 curl -OJL https://github.com/ysaxon/boltworks/tarball/master Once you have a copy of the source, you can install it with: 1 pip install .","title":"From source"},{"location":"usage/","text":"Usage \u00b6 To use Slack Bolt UI Extensions in a project 1 import boltworks","title":"usage"},{"location":"usage/#usage","text":"To use Slack Bolt UI Extensions in a project 1 import boltworks","title":"Usage"}]}